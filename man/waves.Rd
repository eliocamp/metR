% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FitWave.R
\name{waves}
\alias{waves}
\alias{FitWave}
\alias{BuildField}
\alias{FitQsWave}
\alias{BuildQsField}
\title{Fourier transform}
\usage{
FitWave(y, k = 1)

BuildField(x, amplitude, phase, k, wave = list(k = k, amplitude = amplitude,
  phase = phase), sum = TRUE)
}
\arguments{
\item{y}{numeric vector to transform}

\item{k}{numeric vector of wave numbers}

\item{x}{numeric vector of locations (in radians)}

\item{amplitude}{numeric vector of amplitudes}

\item{phase}{numeric vector of phases}

\item{wave}{optional list output from \code{FitWave}}

\item{sum}{wheter to perform the sum or not (see Details)}
}
\value{
\code{FitWaves} returns a a named list with components
\describe{
\item{k}{wavenumbers}
\item{amplitude}{amplitude of each wavenumber}
\item{phase}{phase of each wavenumber in radians}
\item{r2}{explained variance of each wavenumber}
}

\code{BuildField} returns a vector of the same length of x with the reconstructed
vector if \code{sum} is \code{TRUE} or, instead, a list with components
\describe{
\item{k}{wavenumbers}
\item{x}{the vector of locations}
\item{y}{the reconstructed signal of each wavenumber}
}
}
\description{
Perform a fourier transform of the data and return the
}
\details{
\code{FitWave} uses \link{fft} to make a fourier transform of the
data and then returns a list of parameters for each wave number kept.
The  amplitude (A), phase (\eqn{\phi}) and wave number (k) satisfy:
\deqn{y = \sum A cos((x - \phi)k)}
The phase is calculated so that it lies between 0 and \eqn{2\pi/k} so it
represents the location (in radians) of the first maximum of each wave number.
For the case of k = 0 (the mean), phase is arbitrarily set to 0.

\code{BuildField} is \code{FitWave}'s inverse. It reconstructs the original data for
selected wavenumbers. If \code{sum} is \code{TRUE} (the default) it performs the above
mentioned sum and returns a single vector. If is \code{FALSE}, then it returns a list
of k vectors consisting of the reconstructed signal of each wavenumber.
}
\examples{
data(aao)
library(data.table)
# January mean of geopotential height
jan <- aao[month(date) == 1, .(gh = mean(gh)), by = .(lon, lat)]

# Stationary waves for each latitude
jan.waves <- jan[, FitWave(gh, 1:4), by = .(lat)]
library(ggplot2)
ggplot(jan.waves, aes(lat, amplitude, color = factor(k))) +
    geom_line()

# Build field of wavenumber 1
jan[, gh.1 := BuildField(lon*pi/180, wave = FitWave(gh, 1)), by = .(lat)]
ggplot(RepeatCircular(jan), aes(lon, lat)) +
    geom_contour(aes(z = gh.1, color = ..level..)) +
    coord_polar()

# Build fields of wavenumber 1 and 2
waves <- jan[, BuildField(lon*pi/180, wave = FitWave(gh, 1:2), sum = FALSE), by = .(lat)]
waves[, lon := x*180/pi]
ggplot(RepeatCircular(waves), aes(lon, lat)) +
    geom_contour(aes(z = y, color = ..level..)) +
    facet_wrap(~k) +
    coord_polar()

# Field with waves 0 to 2 filtered
jan[, gh.no12 := gh - BuildField(lon*pi/180, wave = FitWave(gh, 0:2)), by = .(lat)]
ggplot(RepeatCircular(jan), aes(lon, lat)) +
    geom_contour(aes(z = gh.no12, color = ..level..)) +
    coord_polar()

}
\seealso{
Other meteorology functions: \code{\link{Derivate}},
  \code{\link{EOF}}, \code{\link{GeostrophicWind}},
  \code{\link{WaveFlux}}, \code{\link{thermodynamics}}
}
\concept{meteorology functions}
