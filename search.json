[{"path":[]},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_contour_fill","dir":"Articles","previous_headings":"Geoms and stats","what":"geom_contour_fill()","title":"Visualization tools","text":"geom bit long story. ggplot2 introduced geom_contour_filled(), ‘canonical’ way get filled contours using stat_contour() polygon geom mapping fill level (see issue). ugly bad didn’t work cases, threw together hacks make work, thus metR::geom_contour_fill() born. , Claus Wilke created {isoband}, lead ggplot2 finally getting proper implementation filled contours. Since implementation worked much better Frankenstein’s monster hacks workarounds, decided scrub adopt {isoband} well. history R landscape left metR::geom_contour_fill() ggplot2::geom_contour_filled() almost identical implementations. use one ? didn’t just deprecate seemingly redundant function? , intervening time metR::geom_contour_fill() evolved now provides many functionality missing ggplot2’s counterpart.","code":""},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"breaks-can-be-a-function-","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"breaks can be a function.","title":"Visualization tools","text":"main control parameter contour family functions breaks argument, sets levels draw contour lines. geom_contour_fill() argument can function takes binwidth range data. allows great flexibility. example, common meteorological science draw contours zero level. Passing MakeBreaks() breaks argument allows control binwidth, also levels draw.","code":"ggplot(temperature[lon %~% 180], aes(lat, lev, z = air.z)) +     geom_contour_fill(breaks = MakeBreaks(binwidth = 2, exclude = 0)) +     scale_fill_divergent(breaks = MakeBreaks(binwidth = 2, exclude = 0))"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"infilling-of-missing-values","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"Infilling of missing values","title":"Visualization tools","text":"geom_contour_fill() geom_contour_filled() work fine missing values, leave somewhat ugly empty patch found.  OK behaviour, sometimes ’s visually appealing fill missing areas. na.fill argument allows control values imputed. can take number, function function takes vector values returns one number, TRUE, case use metR::Impute2D() interpolate missing values.","code":"data(volcano) volcano <- setDT(reshape2::melt(volcano)) volcano[, value.gap := value] volcano[(Var1 - 40)^2 + (Var2 - 35)^2 < 50, value.gap := NA]  ggplot(volcano, aes(Var1, Var2, z = value.gap)) +     geom_contour_fill() ggplot(volcano, aes(Var1, Var2, z = value.gap)) +     geom_contour_fill(na.fill = TRUE)  #> Warning: Imputing missing values."},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"on-the-fly-projecting","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"On-the-fly projecting","title":"Visualization tools","text":"Contouring works regular grids (although see {contoureR} implementation accepts non-regular girds). Sometimes data regular coordinate system need plot another. example, data regular longitude latitude coordinate system, regular x y coordinates lambertian grid.   know projection string, can pass proj argument get filled contours longitude latitude space (needs {proj4} installed).   can actually pass arbitrary function proj. take iso object returned isoband package contour information return modified contours.","code":"data(surface) ggplot(surface, aes(lon, lat)) +     geom_point(aes(color = height)) ggplot(surface, aes(x, y)) +     geom_point(aes(color = height)) proj_string <- \"+proj=lcc +lat_1=-30.9659996032715 +lat_2=-30.9659996032715 +lat_0=-30.9660034179688 +lon_0=-63.5670013427734 +a=6370000 +b=6370000\"  ggplot(surface, aes(x, y)) +     geom_contour_fill(aes(z = height)) ggplot(surface, aes(x, y)) +     geom_contour_fill(aes(z = height), proj = proj_string)"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"clipping","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"Clipping","title":"Visualization tools","text":"clip argument takes simple feature polygon clips contours interior polygon. Clipping done proj applied.","code":"argentina <- rnaturalearth::ne_countries(country = \"argentina\", returnclass = \"sf\") ggplot(surface, aes(x, y)) +     geom_contour_fill(aes(z = height), proj = proj_string, clip = argentina)"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"on-the-fly-kriging","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"On the fly kriging","title":"Visualization tools","text":"everything fails data regular grid coordinate system, can use kriging interpolate regular grid plot using contours. Setting kriging argument toTRUE uses {kriging} krige (verb?) data computing contours. , example, volcano dataset sampled perturbed create dataset irregularly spaced points. Using kriging, geom_contour_fill() can recover general shape.","code":"set.seed(42)  some_volcano <- volcano[sample(.N, .N/7)]   # select 70% of the points some_volcano[, Var1 := Var1 + rnorm(.N)]    # add some random noise some_volcano[, Var2 := Var2 + rnorm(.N)]  ggplot(some_volcano, aes(Var1, Var2)) +     geom_point(aes(color = value)) ggplot(some_volcano, aes(Var1, Var2)) +     geom_contour_fill(aes(z = value), kriging = TRUE) +     geom_point(size = 0.2)"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"unequal-breaks-between-facets","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"Unequal breaks between facets","title":"Visualization tools","text":"ggplot2’s geom_contour_filled() computes breaks using data. great means breaks consistent panels using facet_grid(). want compute breaks separately panel, can use geom_contour_fill()’s global.breaks argument. default, separation levels always . Good comparison, case panel left lacks detail.  global.breaks = FALSE, binwidth longer panel now can see detail leftmost panel.  features also available regular contours geom_contour2() function.","code":"ggplot(temperature[lev %in% c(1000, 300)], aes(lon, lat, z = air.z)) +     geom_contour_fill() +     scale_fill_divergent() +     facet_grid(~lev) ggplot(temperature[lev %in% c(1000, 300)], aes(lon, lat, z = air.z)) +     geom_contour_fill(global.breaks = FALSE) +     scale_fill_divergent() +     facet_grid(~lev)"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"computed-variables","dir":"Articles","previous_headings":"Geoms and stats > geom_contour_fill()","what":"Computed variables","title":"Visualization tools","text":"Like ggplot::geom_contour_filled(), geom_contour_fill() computes several relevant variables. two important ones level_mid (also called int.level backwards compatibility reasons) level. former (default) numeric value corresponds midpoint levels latter ordered factor represents range contour.   big difference two variables one compatible continuous scales works discrete scales. advantage using level_mid preserves actual continuous nature data, allows use meaningful continuous scales scale_fill_divergent() results proper colours breaks equally spaced. disadvantage scale function information discretisation, thus hard use synchronise breaks define levels contours breaks shown color guide. third important computed variable level_d, identical level forces scale match breaks data automatically.  See discretised_scale section way using continuous sales discretised data.","code":"ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill() ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill(aes(fill = after_stat(level))) ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill(aes(fill = after_stat(level_d)))"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_text_contour-and-geom_label_contour","dir":"Articles","previous_headings":"Geoms and stats","what":"geom_text_contour and geom_label_contour","title":"Visualization tools","text":"Labelling contours also problematic aspect ggplot2. geom_text_contour() geom_label_contour() can use automatically add text labels flattest part contour.  default labels every 2nd contour (can changed skip parameter) rotates follow angle contour (available geom_label_contour()). Since datasets can small contours labelled clarity, min.size argument specifies minimum points contour order labelled. Notice labels drawn top contours? problem geom_contour() doesn’t know ’s labelled; geom_text_contour() addresses issue allowing draw stroke around text.  can full control labels placed label.placer argument. takes function takes vector x y values returns logical vector length indicate points labels . 5 build placement functions: label_placer_flattest(): default. computes curvature angle points selects point minimizes sum numbers. Therefore, tries label flattest horizontal part contour. label_placer_fraction(): takes vector numbers ranging 0 1 representing tu put label relation length contour. , using 0.5 means put label midpoint. label_placer_n(): Places n labels approximately equally spaced along contour. label_placer_random(): puts label random places. ¯\\_(ツ)_/¯ . label_placer_all(): puts label every point. Probably best use .","code":"ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill() +     geom_contour(color = \"black\") +     geom_text_contour() +     scale_fill_divergent() ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill() +     geom_contour2(color = \"black\") +     geom_text_contour(stroke = 0.2) +     scale_fill_divergent() ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill() +     geom_contour2(color = \"black\") +     geom_text_contour(stroke = 0.2, label.placer = label_placer_random()) +     scale_fill_divergent()"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_contour_tanaka","dir":"Articles","previous_headings":"Geoms and stats","what":"geom_contour_tanaka","title":"Visualization tools","text":"Illuminated contours (aka Tanaka contours) use varying brightness width create illusion relief. can help distinguishing concave convex areas (local minimums maximums), specially black white plots. also allows photocopy safe plots divergent colour palettes, just looks cool.","code":"ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill() +     geom_contour_tanaka() +     scale_fill_divergent()"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"stat_subset","dir":"Articles","previous_headings":"Geoms and stats","what":"stat_subset","title":"Visualization tools","text":"metR also stat_subset() makes subset data according subset aesthetic. makes possible show part data one geom without needing specify data argument (specially useful data plotted result long pipe actually assigned data.frame). somewhat limited use perform statistical transformations data. example, can used correlation field want mark points significant correlations:  Another possible use quickly mask missing values.","code":"data(geopotential)    # geopotential height at 700hPa for the Southern Hemisphere.   ggplot(geopotential[, gh.base := gh[lon == 120 & lat == -50], by = date][     , .(correlation = cor(gh.base, gh)),      by = .(lon, lat)],     aes(lon, lat, z = correlation)) +     geom_contour_fill(breaks = MakeBreaks(0.1)) +     stat_subset(aes(subset = correlation > 0.5),                 geom = \"point\", size = 0.1) +     scale_fill_divergent() ggplot(volcano, aes(Var1, Var2, z = value.gap)) +     geom_contour_fill(na.fill = TRUE) +     stat_subset(aes(subset = is.na(value.gap)), geom = \"raster\",                  fill = \"#a56de2\")"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_vector-and-geom_arrow","dir":"Articles","previous_headings":"Geoms and stats","what":"geom_vector and geom_arrow","title":"Visualization tools","text":"Plotting arrows can pain. , ‘canonical’ way plotting vectors use geom_segment() specify x, y, xend yend aesthetics can lot typing one data location displacement (velocity). Instead, metR‘s geom_vector() geom_arrow() draw vectors defined lateral displacements (dx, dy) magnitude angle. also useful parameters like min.mag, controls minimum magnitude arrow drawn (useful highlighting areas strong ’flow’) skip, draws nth arrow x y directions. geoms essentially , except geom_arrow() defaults preserving direction coordinate transformations regardless plot aspect ratio. recommended arrows meant convey direction flow point instead description shape flow related plot coordinates. , example, can plot temperature gradient like :  example, t.dx t.dy represent displacements units x y dimension, using geom_vector() arrow points perpendicular contours even change coordinate system.  want plot (horizontal) direction changes height makes sense use geom_arrow() (geom_vector(preserve.dir = TRUE))  case, arrow 45° angle represents temperature gradient Southwest regardless x y scales. start direction arguments adjust behaviour arrows. useful working winds meteorological standard (0° means wind North 90° means wind East).","code":"temperature[, c(\"t.dx\", \"t.dy\") := Derivate(air.z ~ lon + lat,                                             cyclical = c(TRUE, FALSE)),              by = lev]  (g <- ggplot(temperature[lev == 500], aes(lon, lat)) +         geom_contour_fill(aes(z = air.z)) +         geom_vector(aes(dx = t.dx, dy = t.dy), skip.x = 2,                      skip.y = 1) +         scale_mag()) g + coord_polar() ggplot(temperature[lon %between% c(100, 200) & lat == -50], aes(lon, lev)) +      geom_arrow(aes(dx = dx(t.dx, lat), dy = dy(t.dy)), skip = 1) +     scale_y_level() +     scale_mag()"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_streamline","dir":"Articles","previous_headings":"Geoms and stats","what":"geom_streamline","title":"Visualization tools","text":"Streamlines paths tangential vector field provide intuitive way visualizing vector fields. geom_streamline() computes streamlines via Euler integration.  several parameters control feel result. L res control length resolution, skip parameters change amount streamlines. depth control simulation can accomplished S dt parameters. Since streamlines imply tight relationship vector field spatial dimensions, ’s important units compatible. wind field m/s longitude-latitude grid first converted degrees/s. functions dlon() dlat() easy way . tight coupling also means robust coordinate transformations.  stat_streamline() computes three useful variables. step integration step, dx dy components vector field point. can used visualize information field point, give sense direction without arrows.","code":"(g <- ggplot(temperature[lev == 500], aes(lon, lat)) +      geom_contour_fill(aes(z = air.z)) +      geom_streamline(aes(dx = t.dy, dy = -t.dx), L = 10, res = 2,                         arrow.length = 0.3, xwrap = c(0, 360))) g + coord_polar() ggplot(temperature[lev == 500], aes(lon, lat)) +     geom_streamline(aes(dx = t.dy, dy = -t.dx, size = after_stat(step),                          alpha = after_stat(step),                         color = after_stat(sqrt(dx^2 + dy^2))), arrow = NULL,                     L = 10, res = 2, xwrap = c(0, 360), lineend = \"round\") +      scale_color_viridis_c(guide = \"none\") +     scale_size(range = c(0, 1), guide = \"none\") +     scale_alpha(guide = \"none\") #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> This warning is displayed once per session. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated."},{"path":[]},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"discretised_scale","dir":"Articles","previous_headings":"Scales","what":"discretised_scale()","title":"Visualization tools","text":"use geom_contour() geom_contour_fill() generates problem geoms implicitly discretise continuous variable, ’s hard communicate discretisation colour scale. particular, handy show discretised version colour scale values labelled sync contour levels. One way achieving use level stat, –discussed previously– discrete variable. , one can use ggplot2::guide_colorsteps() get nice looking guide.  can work, example shows limitations. Since scale real understanding underlying numbers, breaks colours always distributed evenly even shouldn’t. reason ’s also possible use diverging colour scales set midpoint. , solution use scale_fill_discretised():  type scale understand discrete values underlying continuous nature. means scale can modified referencing continuous values. example, using divergent scale setting midpoint.","code":"ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill(aes(fill = after_stat(level)), breaks = c(-10, -8, -6, -2, -1, 0, 6, 8, 10)) +     guides(fill = guide_colorsteps()) ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill(aes(fill = after_stat(level)), breaks = c(-10, -8, -6, -2, -1, 0, 6, 8, 10)) +     scale_fill_discretised() ggplot(temperature[lev == 300], aes(lon, lat, z = air.z)) +     geom_contour_fill(aes(fill = after_stat(level)), breaks = c(-10, -8, -6, -2, -1, 0, 6, 8, 10)) +     scale_fill_divergent_discretised(midpoint = 3)"},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"other-scales","dir":"Articles","previous_headings":"Scales","what":"Other scales","title":"Visualization tools","text":"Many meteorological fields defined longitude×latitude×level grid, metR includes scales dimension. glorified wrappers around scale_*_continuous() sensible defaults , case scale_*_level(), implementation reverselog_trans(). also scale_color_divergent() scale_fill_divergent() wrappers around scale_*_gradient2() sane default colours positive negative values –particularly useful plotting anomaly values. see scales work, let’s visualize vertical distribution temperature anomalies zonal mean.  fine, since pressure levels roughly proportional e−z\\mathrm{e}^{-z} meteorology usually plot vertical coordinate −log(p)-\\log(p). However, ggplot2 scale_y_log10() scale_y_reverse(), don’t work together. metR defines new transformation reverselog_trans() can used scale default scale_*_level(). hand, scale_*_latitude() (scale_*_longitude()) defaults expand c(0, 0), also ticks argument specifies spacing breaks -90 90 case scale_*_latitude(), 0 360 case scale_*_longitude(). scales default printing label, since usually dimensions understood shape plot.  Note: scale_*_longitude() (currently) assumes data goes 0° 360° puts labels -180° 180°. idiosyncratic choice stems fact model output usually [0; 360) range ’s easier read maps (-180; 180] range. may change future.","code":"# Plot made with base ggplot (g <- ggplot(temperature[lon %~% 180], aes(lat, lev, z = air.z)) +      geom_contour2(aes(color = after_stat(level)))) g +      scale_y_level() +     scale_x_latitude(ticks = 15, limits = c(-90, 90)) +     scale_color_divergent()"},{"path":[]},{"path":"https://eliocamp.github.io/metR/articles/Visualization-tools.html","id":"geom_relief","dir":"Articles","previous_headings":"Other goodies","what":"geom_relief","title":"Visualization tools","text":"geom produces shaded relief data. doesn’t really map data per se, provides intuitive representation hills valleys can used background plotting actual data.","code":"ggplot(volcano, aes(Var1, Var2)) +     geom_relief(aes(z = value))"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"getting-data","dir":"Articles","previous_headings":"","what":"Getting data","title":"Working with data","text":"metR implements functions easily load data R either local files remote locations.","code":""},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"readnetcdf","dir":"Articles","previous_headings":"Getting data","what":"ReadNetCDF","title":"Working with data","text":"function ReadNetCDF() relies ncdf4 package read NetCDF files ease. intelligently reads dimensions data returns tidy data.table optional keyed columns faster processing afterwards. can also return array named dimensions vector, case adding new columns existing data.table. Now know name dimensions data, can read . ReadNetCDF() can also read (continuous) subset data.  Since consuming part reading file melting multidimensional array tidy data.table, wanted add another variable data.table save time returning vector. utmost importance variables exact grid.  ReadNetCDF() can read multiple variables time, = \"vector\" output actually return list vectors (integrates seamlessly data.table syntax). one variables degenerate dimensions (dimensions length 1) recycled. means file Sea Surface Temperatures (2D field) Air Temperature (3D field), returned data.table fill observation Air Temperature Sea Surface Temperature vertical level. netCDF format flexible function tested every possible file things may break strange cases. file read function, please submit issue.","code":"library(metR) library(data.table) library(ggplot2)  # If out = \"vars\", returns information about the available variables and  # dimensions file <- system.file(\"extdata\", \"temperature.nc\", package = \"metR\") GlanceNetCDF(file) #> ----- Variables -----  #> air: #>     mean Daily Air temperature in degK #>     Dimensions: lon by lat by level by time #>  #>  #> ----- Dimensions -----  #>   time: 1 values from 2010-07-09 to 2010-07-09  #>   level: 17 values from 10 to 1000 millibar #>   lat: 73 values from -90 to 90 degrees_north #>   lon: 144 values from 0 to 357.5 degrees_east air <- ReadNetCDF(file, subset = list(lat = 90:0, level = 925))   ggplot(air, aes(lon, lat)) +   geom_contour2(aes(z = air, color = after_stat(level))) air[, air2 := ReadNetCDF(file, out = \"vector\",                          subset = list(lat = 90:0, level = 300))]  ggplot(air, aes(lon, lat)) +   geom_contour2(aes(z = air2, color = after_stat(level)))"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"gettopography","dir":"Articles","previous_headings":"Getting data","what":"GetTopography","title":"Working with data","text":"GetTopography() retrieves topographic data ETOPO1 Global Relief Model convenient tidy data.table. default, also stores cached version. example, let’s look global relief map 1/2° resolution ugly colour palette.","code":"# Not run because it needs internet access # world <- GetTopography(0, 360, 90, -90, resolution = 1)  # ggplot(world, aes(lon, lat)) + #     geom_raster(aes(fill = h/1000)) + #     geom_contour2(aes(z = h), breaks = 0, color = \"black\", size = 0.5) + #     coord_fixed(expand = FALSE) + #     scale_fill_gradientn(colors = topo.colors(6)[c(1, 2, 3, 4, 6)],  #                          values = scales::rescale(c(-11, 0, 0, 2, 7)), #                          guide = \"none\") + #     theme_void()"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"maskland","dir":"Articles","previous_headings":"Getting data","what":"MaskLand","title":"Working with data","text":"Related problem, MaskLand() returns logical vector TRUE point land.  , can compare mean temperature land sea latitude.  resolution MaskLand() , principle, limited polygons used mask. Currently can use maps maps package (see ?maps::map).","code":"air[, land := MaskLand(lon, lat)]  ggplot(air, aes(lon, lat)) +   geom_tile(aes(fill = land)) +   coord_quickmap() ggplot(air[, .(air = mean(air) - 273.15), by = .(lat, land)],        aes(lat, air)) +   geom_line(aes(color = land))"},{"path":[]},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"eof","dir":"Articles","previous_headings":"Manipulate data","what":"EOF","title":"Working with data","text":"Empirical Orthogonal Functions (also known Principal Component Analysis) widely use technique dimensional reduction large datasets. R multiple packages implement methodology (fact, base R two functions) , IMHO, awkward interfaces don’t interact well data.table (dplyr) syntax. metR’s EOF() essentially performs Singular Value Decomposition data returns left right singular vectors, singular values tidy format. returned list data.tables left (right) singular vectors fields defined dimensions left (right) hand formula. case, right data.table holds spatial fields left data.table holds timeseries. order right hand side left hand side formula reversed, rotate == FALSE, result . Rotation singular vectors perform via stats::varimax() perform (scaled) right singular vector. completion, let’s plot Principal Component.   1st Principal Component clearly Antarctic Oscillation 2nd Principal Component looks like Pacific–South American Pattern.","code":"data(geopotential) # Weigthed geopotential anomaly geopotential[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)), by = .(lon, lat, month(date))]  eof <- EOF(gh.t.w ~ date | lon + lat, data = geopotential, n = 1:2) str(eof) #> List of 3 #>  $ left :Classes 'data.table' and 'data.frame':  144 obs. of  3 variables: #>   ..$ date  : Date[1:144], format: \"1990-01-01\" \"1990-02-01\" ... #>   ..$ PC    : Ord.factor w/ 2 levels \"PC1\"<\"PC2\": 1 1 1 1 1 1 1 1 1 1 ... #>   ..$ gh.t.w: num [1:144] 0.0633 -0.1145 -0.0432 0.1926 0.1539 ... #>   ..- attr(*, \".internal.selfref\")=<externalptr>  #>  $ right:Classes 'data.table' and 'data.frame':  8064 obs. of  4 variables: #>   ..$ lon   : num [1:8064] 0 2.5 5 7.5 10 12.5 15 17.5 20 22.5 ... #>   ..$ lat   : num [1:8064] -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 ... #>   ..$ PC    : Ord.factor w/ 2 levels \"PC1\"<\"PC2\": 1 1 1 1 1 1 1 1 1 1 ... #>   ..$ gh.t.w: num [1:8064] 2.32e-04 4.67e-06 -1.17e-04 -1.47e-04 -1.12e-04 ... #>   ..- attr(*, \".internal.selfref\")=<externalptr>  #>  $ sdev :Classes 'data.table' and 'data.frame':  2 obs. of  3 variables: #>   ..$ PC: Ord.factor w/ 2 levels \"PC1\"<\"PC2\": 1 2 #>   ..$ sd: num [1:2] 7050 4228 #>   ..$ r2: num [1:2] 0.318 0.114 #>   ..- attr(*, \".internal.selfref\")=<externalptr>  #>  - attr(*, \"call\")= language EOF(formula = gh.t.w ~ date | lon + lat, n = 1:2, data = geopotential) #>  - attr(*, \"class\")= chr [1:2] \"eof\" \"list\" #>  - attr(*, \"suffix\")= chr \"PC\" #>  - attr(*, \"value.var\")= chr \"gh.t.w\" #>  - attr(*, \"engine\")=function (A, nv, nu) ggplot(eof$right, aes(lon, lat)) +   geom_contour_fill(aes(z = gh.t.w), binwidth = 0.01) +   scale_fill_divergent() +   coord_polar() +   facet_wrap(~PC) ggplot(eof$left, aes(date, gh.t.w)) +   geom_line(aes(color = PC)) +   scale_x_date(expand = c(0, 0))"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"imputeeof","dir":"Articles","previous_headings":"Manipulate data","what":"ImputeEOF","title":"Working with data","text":"shown , EOF() needs complete data matrix. Imputing missing values huge problem ’s lot different algorithms. metR offers ImputeEOF(), implementation DINEOF algorithm imputation missing data. interface similar EOF() returns vector imputed values. imputed vector returned along Root Mean Square Error estimated cross-validation number EOFs used imputation attributes. case, 5 EOFs imputed values estimated rmse 26.65.","code":"geopotential <- geopotential[] geopotential[sample(1:.N, .N*0.8), gh.na := gh]  geopotential[, imputed := ImputeEOF(gh.na ~ lon + lat | date, max.eof = 5)] str(geopotential) #> Classes 'data.table' and 'data.frame':   290304 obs. of  8 variables: #>  $ lon    : num  0 2.5 5 7.5 10 12.5 15 17.5 20 22.5 ... #>  $ lat    : num  -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 -22.5 ... #>  $ lev    : int  700 700 700 700 700 700 700 700 700 700 ... #>  $ gh     : num  3164 3163 3162 3162 3163 ... #>  $ date   : Date, format: \"1990-01-01\" \"1990-01-01\" ... #>  $ gh.t.w : num  -3.82 -3.59 -2.86 -2.4 -2.07 ... #>  $ gh.na  : num  3164 3163 3162 3162 3163 ... #>  $ imputed: num  3164 3163 3162 3162 3163 ... #>   ..- attr(*, \"eof\")= int 5 #>   ..- attr(*, \"rmse\")= num 26.6 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"interpolate","dir":"Articles","previous_headings":"Manipulate data","what":"Interpolate","title":"Working with data","text":"Interpolate() performs linear interpolation using data.table-friendly syntax. can used new grid add interpolated values existing grid. ’s easy interpolate multiple values formula interface. add interpolated values existing data.table use grid = FALSE.","code":"# new grid x.out <- seq(0, 360, by = 10) y.out <- seq(-90, 0, by = 10)  interpolated <- geopotential[, Interpolate(gh | gh.t.w ~ lon + lat, x.out, y.out),                               by = date] geopotential[, gh.new := Interpolate(gh ~ lon + lat, lon, lat,                                       data = interpolated[date == d],                                      grid = FALSE)$gh,               by = .(d = date)]"},{"path":[]},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"derivates","dir":"Articles","previous_headings":"Physics","what":"Derivates","title":"Working with data","text":"Derivation bread butter researcher Derivate() offers convenient interface derivation using finite differences multidimensional data. support cyclical boundary conditions special case spherical coordinates (think: Earth).  several wrappers around Derivate() perform common related operations, Laplacian(), Divergence() Vorticity().","code":"geopotential[date == date[1],    # think: gh as a function of lon and lat              c(\"gh.dlon\", \"gh.dlat\") := Derivate(gh ~ lon + lat,                                                   cyclical = c(TRUE, FALSE),                                                   sphere = TRUE)]   ggplot(geopotential[date == date[1]], aes(lon, lat)) +   geom_contour_fill(aes(z = gh)) +   geom_vector(aes(dx = gh.dlon, dy = gh.dlat), skip = 2) +   scale_mag() +   coord_quickmap()"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"geostrophicwind","dir":"Articles","previous_headings":"Physics","what":"GeostrophicWind","title":"Working with data","text":"Finally, function GeostrophicWind() computes geostrophic wind geopotential height.","code":"geopotential[date == date[1], c(\"u\", \"v\") := GeostrophicWind(gh, lon, lat)]  ggplot(geopotential[date == date[1]], aes(lon, lat)) +   geom_contour2(aes(z = gh)) +   geom_vector(aes(dx = dlon(u, lat), dy = dlat(v)),                skip.y = 1, skip.x = 2) +   scale_mag() +   coord_quickmap()"},{"path":"https://eliocamp.github.io/metR/articles/Working-with-data.html","id":"thermodynamics","dir":"Articles","previous_headings":"Physics","what":"Thermodynamics","title":"Working with data","text":"metR offers several functions related thermodynamical processes atmosphere (see ?thermodynamics). IdealGas(), Adiabat(), VirtualTemperature(), MixingRatio(), ClausiusClapeyron() DewPoint(). function represents different physical relationship variables computes one others. example, IdealGas() uses ideal gas law compute pressure, temperature density. Different variables can derived combining functions. example, ’s easy calculate relative humidity data temperature dewpoint, saturation mixing ratio pressure temperature finally actual mixing ratio. course, w can also computed DewPoint(p, td = td) gives essentially result: 0.0014548.","code":"# Density of air at 20°C and 1030hPa. (rho <- IdealGas(1013*100, 20 + 273.15)) #> [1] 1.203788  # Of course, the temperature of air at that density  # and same pressure is 20°C. IdealGas(1013*100, rho = rho) - 273.15 #> [1] 20 # Relative humidity from T and Td t <- 25 + 273.15 td <- 20 + 273.15 p <- 1000000 (rh <- ClausiusClapeyron(td)/ClausiusClapeyron(t)) #> [1] 0.7380251  # Mixing ratio ws <- MixingRatio(p, ClausiusClapeyron(t)) (w <- ws*rh) #> [1] 0.001456004"},{"path":"https://eliocamp.github.io/metR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Elio Campitelli. Maintainer, author.","code":""},{"path":"https://eliocamp.github.io/metR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"person, c) c= (2021). metR: Tools Easier Analysis Meteorological Fields. doi:10.5281/zenodo.2593516, R package version 0.18.3.9000, https://eliocamp.github.io/metR/.","code":"@Manual{,   title = {metR: Tools for Easier Analysis of Meteorological Fields},   author = {{person} and comment = c)},   year = {2021},   note = {R package version 0.18.3.9000},   url = {https://eliocamp.github.io/metR/},   doi = {10.5281/zenodo.2593516}, }"},{"path":"https://eliocamp.github.io/metR/index.html","id":"metr-","dir":"","previous_headings":"","what":"Tools for Easier Analysis of Meteorological Fields","title":"Tools for Easier Analysis of Meteorological Fields","text":"metR packages several functions utilities make R better handling meteorological data tidy data paradigm. started mostly sa packaging assorted wrappers tricks wrote day day work researcher atmospheric sciences. Since , grown organically needs feedback users. Conceptually ’s divided visualization tools data tools. former geoms, stats scales help plotting using ggplot2, stat_contour_fill() scale_y_level(), later functions common data processing tools atmospheric sciences, Derivate() EOF(); implemented work data.table paradigm, also work regular data frames. Currently metR development maturing. functions check arguments tests. However, functions might change ’s interface, functionality can moved packages, please bear mind.","code":""},{"path":"https://eliocamp.github.io/metR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Easier Analysis of Meteorological Fields","text":"can install metR CRAN : development version : need read netcdf files, might need install netcdf udunits2 libraries. Ubuntu ’s derivatives can done typing","code":"install.packages(\"metR\") if (!requireNamespace(\"pak\", quietly = TRUE)) {     install.packages(\"pak\") } pak::pak(\"metR\") sudo apt install libnetcdf-dev netcdf-bin libudunits2-dev"},{"path":"https://eliocamp.github.io/metR/index.html","id":"citing-the-package","dir":"","previous_headings":"","what":"Citing the package","title":"Tools for Easier Analysis of Meteorological Fields","text":"use metR research, please consider citing . can get citation information ","code":"citation(\"metR\") #> To cite metR in publications use: #>  #>  #>  #> A BibTeX entry for LaTeX users is #>  #>   @Manual{, #>     title = {metR: Tools for Easier Analysis of Meteorological Fields}, #>     author = {Elio Campitelli}, #>     year = {2021}, #>     note = {R package version 0.18.3}, #>     url = {https://eliocamp.github.io/metR/}, #>     doi = {10.5281/zenodo.2593516}, #>   }"},{"path":"https://eliocamp.github.io/metR/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Tools for Easier Analysis of Meteorological Fields","text":"example easily perform Principal Components Decomposition (EOF) monthly geopotential height, compute geostrophic wind associated field plot field filled contours wind streamlines.   can read vignettes: Visualization tools Working data.","code":"library(metR) library(data.table) library(ggplot2) data(geopotential) # Use Empirical Orthogonal Functions to compute the Antarctic Oscillation geopotential <- copy(geopotential) geopotential[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)),       by = .(lon, lat, month(date))] aao <- EOF(gh.t.w ~ lat + lon | date, data = geopotential, n = 1) aao$left[, c(\"u\", \"v\") := GeostrophicWind(gh.t.w/sqrt(cos(lat*pi/180)),                                                      lon, lat)]  # AAO field binwidth <- 0.01 ggplot(aao$left, aes(lon, lat)) +     geom_contour_fill(aes(z = gh.t.w/sqrt(cos(lat*pi/180)),                            fill = after_stat(level)), binwidth = binwidth,                       xwrap = c(0, 360)) +     geom_streamline(aes(dx = dlon(u, lat), dy = dlat(v)),                     linewidth = 0.4, L = 80, skip = 3, xwrap = c(0, 360)) +     scale_x_longitude() +     scale_y_latitude(limits = c(-90, -20)) +     scale_fill_divergent_discretised(name = \"AAO pattern\") +     coord_polar() #> Warning in .check_wrap_param(list(...)): 'xwrap' and 'ywrap' will be #> deprecated. Use ggperiodic::periodic insead. # AAO signal ggplot(aao$right, aes(date, gh.t.w)) +     geom_line() +     geom_smooth(span = 0.4) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"https://eliocamp.github.io/metR/reference/Anomaly.html","id":null,"dir":"Reference","previous_headings":"","what":"Anomalies — Anomaly","title":"Anomalies — Anomaly","text":"Saves keystrokes computing anomalies.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Anomaly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anomalies — Anomaly","text":"","code":"Anomaly(x, baseline = seq_along(x), ...)"},{"path":"https://eliocamp.github.io/metR/reference/Anomaly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anomalies — Anomaly","text":"x numeric vector baseline logical numerical vector used subsetting x computing mean ... arguments passed mean na.rm","code":""},{"path":"https://eliocamp.github.io/metR/reference/Anomaly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anomalies — Anomaly","text":"numeric vector length x value's distance mean.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/Anomaly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anomalies — Anomaly","text":"","code":"# Zonal temperature anomaly library(data.table) temperature[, .(lon = lon, air.z = Anomaly(air)), by = .(lat, lev)] #>           lat   lev   lon air.z #>         <num> <int> <num> <num> #>      1:    90  1000   0.0     0 #>      2:    90  1000   2.5     0 #>      3:    90  1000   5.0     0 #>      4:    90  1000   7.5     0 #>      5:    90  1000  10.0     0 #>     ---                         #> 178700:   -90    10 347.5     0 #> 178701:   -90    10 350.0     0 #> 178702:   -90    10 352.5     0 #> 178703:   -90    10 355.0     0 #> 178704:   -90    10 357.5     0"},{"path":"https://eliocamp.github.io/metR/reference/ConvertLongitude.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts between longitude conventions — ConvertLongitude","title":"Converts between longitude conventions — ConvertLongitude","text":"Converts longitude [0, 360) [-180, 180) vice versa.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ConvertLongitude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts between longitude conventions — ConvertLongitude","text":"","code":"ConvertLongitude(lon, group = NULL, from = NULL)"},{"path":"https://eliocamp.github.io/metR/reference/ConvertLongitude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts between longitude conventions — ConvertLongitude","text":"lon numeric vector longitude group optional vector groups (length longitude) split edges (see examples) optionally explicitly say convention convert","code":""},{"path":"https://eliocamp.github.io/metR/reference/ConvertLongitude.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts between longitude conventions — ConvertLongitude","text":"group missing, numeric vector length lon. Else, list vectors lon group.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ConvertLongitude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts between longitude conventions — ConvertLongitude","text":"","code":"library(ggplot2) library(data.table) data(geopotential)  ggplot(geopotential[date == date[1]], aes(lon, lat, z = gh)) +     geom_contour(color = \"black\") +     geom_contour(aes(x = ConvertLongitude(lon)))  if (requireNamespace(\"maps\")) { map <- setDT(map_data(\"world\")) map[, c(\"lon\", \"group2\") := ConvertLongitude(long, group, from = 180)]  ggplot(map, aes(lon, lat, group = group2)) +     geom_path() } #> Loading required namespace: maps"},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":null,"dir":"Reference","previous_headings":"","what":"Derivate a discrete variable using finite differences — Derivate","title":"Derivate a discrete variable using finite differences — Derivate","text":"Derivate discrete variable using finite differences","code":""},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derivate a discrete variable using finite differences — Derivate","text":"","code":"Derivate(   formula,   order = 1,   cyclical = FALSE,   fill = FALSE,   data = NULL,   sphere = FALSE,   a = 6371000,   equispaced = TRUE )  Laplacian(   formula,   cyclical = FALSE,   fill = FALSE,   data = NULL,   sphere = FALSE,   a = 6371000,   equispaced = TRUE )  Divergence(   formula,   cyclical = FALSE,   fill = FALSE,   data = NULL,   sphere = FALSE,   a = 6371000,   equispaced = TRUE )  Vorticity(   formula,   cyclical = FALSE,   fill = FALSE,   data = NULL,   sphere = FALSE,   a = 6371000,   equispaced = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derivate a discrete variable using finite differences — Derivate","text":"formula formula indicating dependent independent variables order order derivative cyclical logical vector boundary condition independent variable fill logical indicating whether fill values boundaries forward backwards differencing data optional data.frame containing variables sphere logical indicating whether use spherical coordinates (see details) radius use spherical coordinates (defaults Earth's radius) equispaced logical indicating whether points equispaced .","code":""},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derivate a discrete variable using finite differences — Derivate","text":"one independent variable one dependent variable, numeric vector length dependent variable. two independent variables two dependent variables, list containing directional derivatives dependent variables.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Derivate a discrete variable using finite differences — Derivate","text":"element return vector estimation \\(\\frac{\\partial^n x}{\\partial y^{n}}\\) centred finite differences. sphere = TRUE, first two independent variables assumed longitude latitude (order) degrees. , correction applied derivative units . Using fill = TRUE degrade solution near edges non-cyclical boundary. Use caution. Laplacian(), Divergence() Vorticity() convenient wrappers call Derivate() make appropriate sums. Divergence() Vorticity(), formula must form vx + vy ~ x + y (order).","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/Derivate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derivate a discrete variable using finite differences — Derivate","text":"","code":"data.table::setDTthreads(2) theta <- seq(0, 360, length.out = 20)*pi/180 theta <- theta[-1] x <- cos(theta) dx_analytical <- -sin(theta) dx_finitediff <- Derivate(x ~ theta, cyclical = TRUE)[[1]]  plot(theta, dx_analytical, type = \"l\") points(theta, dx_finitediff, col = \"red\")   # Curvature (Laplacian) # Note the different boundary conditions for each dimension variable <- expand.grid(lon = seq(0, 360, by = 3)[-1],                         lat = seq(-90, 90, by = 3)) variable$z <- with(variable, cos(lat*pi/180*3) + sin(lon*pi/180*2)) variable <- cbind(      variable,      as.data.frame(Derivate(z ~ lon + lat, data = variable,                           cyclical = c(TRUE, FALSE), order = 2))) library(ggplot2) ggplot(variable, aes(lon, lat)) +     geom_contour(aes(z = z)) +     geom_contour(aes(z = z.ddlon + z.ddlat), color = \"red\") #> Warning: Removed 480 rows containing non-finite outside the scale range #> (`stat_contour()`).   # The same as ggplot(variable, aes(lon, lat)) +     geom_contour(aes(z = z)) +     geom_contour(aes(z = Laplacian(z ~ lon + lat, cyclical = c(TRUE, FALSE))),                  color = \"red\") #> Warning: Removed 480 rows containing non-finite outside the scale range #> (`stat_contour()`)."},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical Orthogonal Function — EOF","title":"Empirical Orthogonal Function — EOF","text":"Computes Singular Value Decomposition (also known Principal Components Analysis Empirical Orthogonal Functions).","code":""},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical Orthogonal Function — EOF","text":"","code":"EOF(   formula,   n = 1,   data = NULL,   B = 0,   probs = c(lower = 0.025, mid = 0.5, upper = 0.975),   rotate = NULL,   suffix = \"PC\",   fill = NULL,   engine = NULL )"},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical Orthogonal Function — EOF","text":"formula formula build matrix used SVD decomposition (see Details) n singular values return (NULL, returns ) data data.frame B number bootstrap samples used estimate confidence intervals. Ignored <= 1. probs probabilities lower upper values estimated confidence intervals. named, names used column names. rotate function apply loadings rotate . E.g. varimax rotation use stats::varimax. suffix character name principal components fill value infill implicit missing values NULL data dense. engine function use compute SVD. NULL uses irlba::irlba (installed) largest singular value compute lower half maximum possible value, otherwise uses base::svd. user provides function, needs drop-replacement base::svd (arguments output format).","code":""},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical Orthogonal Function — EOF","text":"eof object just named list data.tables left data.table left singular vectors right data.table right singular vectors sdev data.table singular values, explained variance, , optionally, quantiles estimated via bootstrap methods implemented summary screeplot equivalent ggplot2::autoplot cut.eof predict","code":""},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical Orthogonal Function — EOF","text":"Singular values can computed matrices formula denotes build matrix data. formula form VAR ~ LEFT | RIGHT (see Formula::Formula) VAR variable whose values populate matrix, LEFT represent variables used make rows RIGHT, columns matrix. Think like \"VAR function LEFT RIGHT\". variable combination used formula must identify unique value cell. , example, v ~ x + y | t mean one value v combination x, y t, one row combination x y one row t. result, left right vectors dimensions LEFT RIGHT part formula, respectively. much faster compute singular vectors, advisable set n NULL. irlba package installed, EOF uses irlba::irlba instead base::svd since much faster. bootstrapping procedure follows Fisher et.al. (2016) returns standard deviation singular value.","code":""},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical Orthogonal Function — EOF","text":"Fisher, ., Caffo, B., Schwartz, B., & Zipunnikov, V. (2016). Fast, Exact Bootstrap Principal Component Analysis p > 1 million. Journal American Statistical Association, 111(514), 846–860. doi:10.1080/01621459.2015.1062383","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/EOF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical Orthogonal Function — EOF","text":"","code":"# The Antarctic Oscillation is computed from the # monthly geopotential height anomalies weighted by latitude. library(data.table) data(geopotential) geopotential <- copy(geopotential) geopotential[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)),       by = .(lon, lat, month(date))] #>           lon   lat   lev       gh       date        gh.t.w #>         <num> <num> <int>    <num>     <Date>         <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01 -3.824174e+00 #>      2:   2.5 -22.5   700 3162.516 1990-01-01 -3.591582e+00 #>      3:   5.0 -22.5   700 3162.226 1990-01-01 -2.862909e+00 #>      4:   7.5 -22.5   700 3162.323 1990-01-01 -2.403045e+00 #>      5:  10.0 -22.5   700 3163.097 1990-01-01 -2.067122e+00 #>     ---                                                     #> 290300: 347.5 -90.0   700 2671.484 1995-12-01 -1.449750e-07 #> 290301: 350.0 -90.0   700 2671.484 1995-12-01 -1.449750e-07 #> 290302: 352.5 -90.0   700 2671.484 1995-12-01 -1.449750e-07 #> 290303: 355.0 -90.0   700 2671.484 1995-12-01 -1.449750e-07 #> 290304: 357.5 -90.0   700 2671.484 1995-12-01 -1.449750e-07  eof <- EOF(gh.t.w ~ lat + lon | date, 1:5, data = geopotential,            B = 100, probs = c(low = 0.1, hig = 0.9))  # Inspect the explained variance of each component summary(eof) #> Importance of components: #> Component Explained variance Cumulative variance #>       1                   32%                 32% #>       2                   11%                 43% #>       3                    8%                 51% #>       4                    7%                 58% #>       5                    6%                 64% screeplot(eof)   # Keep only the 1st. aao <- cut(eof, 1)  # AAO field library(ggplot2) ggplot(aao$left, aes(lon, lat, z = gh.t.w)) +     geom_contour(aes(color = after_stat(level))) +     coord_polar()   # AAO signal ggplot(aao$right, aes(date, gh.t.w)) +     geom_line()   # standard deviation, % of explained variance and # confidence intervals. aao$sdev #>       PC       sd        r2     low      hig #>    <ord>    <num>     <num>   <num>    <num> #> 1:   PC1 7050.352 0.3176266 6284.91 7899.572  # Reconstructed fields based only on the two first # principal components field <- predict(eof, 1:2)  # Compare it to the real field. ggplot(field[date == date[1]], aes(lon, lat)) +     geom_contour_fill(aes(z = gh.t.w), data = geopotential[date == date[1]]) +     geom_contour2(aes(z = gh.t.w, linetype = factor(-sign(stat(level))))) +     scale_fill_divergent() #> Warning: `stat(level)` was deprecated in ggplot2 3.4.0. #> ℹ Please use `after_stat(level)` instead."},{"path":"https://eliocamp.github.io/metR/reference/EPflux.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes Eliassen-Palm fluxes. — EPflux","title":"Computes Eliassen-Palm fluxes. — EPflux","text":"Computes Eliassen-Palm fluxes.","code":""},{"path":"https://eliocamp.github.io/metR/reference/EPflux.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes Eliassen-Palm fluxes. — EPflux","text":"","code":"EPflux(lon, lat, lev, t, u, v)"},{"path":"https://eliocamp.github.io/metR/reference/EPflux.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes Eliassen-Palm fluxes. — EPflux","text":"lon longitudes degrees. lat latitudes degrees. lev pressure levels. t temperature Kelvin. u zonal wind m/s. v meridional wind m/s.","code":""},{"path":"https://eliocamp.github.io/metR/reference/EPflux.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes Eliassen-Palm fluxes. — EPflux","text":"data.table columns Flon, Flat Flev giving zonal, meridional vertical components EP Fluxes longitude, latitude level.","code":""},{"path":"https://eliocamp.github.io/metR/reference/EPflux.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes Eliassen-Palm fluxes. — EPflux","text":"Plumb, R. . (1985). Three-Dimensional Propagation Stationary Waves. Journal Atmospheric Sciences, 42(3), 217–229. doi:10.1175/1520-0469(1985)042<0217:OTTDPO>2.0.CO;2  Cohen, J., Barlow, M., Kushner, P. J., & Saito, K. (2007). Stratosphere–Troposphere Coupling Links Eurasian Land Surface Variability. Journal Climate, 20(21), 5335–5343. doi:10.1175/2007JCLI1725.1","code":""},{"path":"https://eliocamp.github.io/metR/reference/FitLm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast estimates of linear regression — FitLm","title":"Fast estimates of linear regression — FitLm","text":"Computes linear regression stats::.lm.fit returns estimate , optionally, standard error regressor.","code":""},{"path":"https://eliocamp.github.io/metR/reference/FitLm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast estimates of linear regression — FitLm","text":"","code":"FitLm(y, ..., intercept = TRUE, weights = NULL, se = FALSE, r2 = se)  ResidLm(y, ..., intercept = TRUE, weights = NULL)  Detrend(y, time = seq_along(y))"},{"path":"https://eliocamp.github.io/metR/reference/FitLm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast estimates of linear regression — FitLm","text":"y numeric vector observations model ... numeric vectors variables used modelling intercept logical indicating whether automatically add intercept weights numerical vector weights (need normalised) se logical indicating whether compute standard error r2 logical indicating whether compute r squared time time vector use detrending. necessary case irregularly sampled timeseries","code":""},{"path":"https://eliocamp.github.io/metR/reference/FitLm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast estimates of linear regression — FitLm","text":"FitLm returns list elements term name regressor estimate estimate regression std.error standard error df degrees freedom r.squared Percent variance explained model (repeated term) adj.r.squared r.squared` adjusted based degrees freedom) ResidLm Detrend returns vector length complete cases regression, NAs returned warning.","code":""},{"path":"https://eliocamp.github.io/metR/reference/FitLm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast estimates of linear regression — FitLm","text":"","code":"# Linear trend with \"signficant\" areas shaded with points library(data.table) library(ggplot2) system.time({   regr <- geopotential[, FitLm(gh, date, se = TRUE), by = .(lon, lat)] }) #>    user  system elapsed  #>   0.342   0.015   0.357   ggplot(regr[term != \"(Intercept)\"], aes(lon, lat)) +     geom_contour(aes(z = estimate, color = after_stat(level))) +     stat_subset(aes(subset = abs(estimate) > 2*std.error), size = 0.05)   # Using stats::lm() is much slower and with no names. if (FALSE) { # \\dontrun{ system.time({   regr <- geopotential[, coef(lm(gh ~ date))[2], by = .(lon, lat)] }) } # }"},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate geostrophic winds — GeostrophicWind","title":"Calculate geostrophic winds — GeostrophicWind","text":"Geostrophic wind geopotential height field.","code":""},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate geostrophic winds — GeostrophicWind","text":"","code":"GeostrophicWind(gh, lon, lat, cyclical = \"guess\", g = 9.81, a = 6371000)"},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate geostrophic winds — GeostrophicWind","text":"gh geopotential height lon longitude degrees lat latitude degrees cyclical boundary condition longitude (see details) g acceleration gravity Earth's radius","code":""},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate geostrophic winds — GeostrophicWind","text":"named list vectors zonal meridional component geostrophic wind.","code":""},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate geostrophic winds — GeostrophicWind","text":"cyclical = \"guess\" (default) function try guess lon covers whole globe set cyclical conditions accordingly. predictable results, set boundary condition explicitly.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/GeostrophicWind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate geostrophic winds — GeostrophicWind","text":"","code":"data(geopotential) geopotential <- data.table::copy(geopotential) geopotential[date == date[1], c(\"u\", \"v\") := GeostrophicWind(gh, lon, lat)] #> Index: <date> #>           lon   lat   lev       gh       date     u           v #>         <num> <num> <int>    <num>     <Date> <num>       <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01    NA  1.08181190 #>      2:   2.5 -22.5   700 3162.516 1990-01-01    NA  0.55189199 #>      3:   5.0 -22.5   700 3162.226 1990-01-01    NA  0.06625043 #>      4:   7.5 -22.5   700 3162.323 1990-01-01    NA -0.29800162 #>      5:  10.0 -22.5   700 3163.097 1990-01-01    NA -0.75064329 #>     ---                                                         #> 290300: 347.5 -90.0   700 2671.484 1995-12-01    NA          NA #> 290301: 350.0 -90.0   700 2671.484 1995-12-01    NA          NA #> 290302: 352.5 -90.0   700 2671.484 1995-12-01    NA          NA #> 290303: 355.0 -90.0   700 2671.484 1995-12-01    NA          NA #> 290304: 357.5 -90.0   700 2671.484 1995-12-01    NA          NA library(ggplot2) ggplot(geopotential[date == date[1]], aes(lon, lat)) +     geom_contour(aes(z = gh)) +     geom_vector(aes(dx = u, dy = v), skip = 2) +     scale_mag()"},{"path":"https://eliocamp.github.io/metR/reference/GetSMNData.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Meteorological data This function is defunct. — GetSMNData","title":"Get Meteorological data This function is defunct. — GetSMNData","text":"Get Meteorological data function defunct.","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetSMNData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Meteorological data This function is defunct. — GetSMNData","text":"","code":"GetSMNData(   date,   type = c(\"hourly\", \"daily\", \"radiation\"),   bar = FALSE,   cache = TRUE,   file.dir = tempdir() )"},{"path":"https://eliocamp.github.io/metR/reference/GetSMNData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Meteorological data This function is defunct. — GetSMNData","text":"date date vector dates fetch data type type data retrieve bar logical object indicating whether show progress bar cache logical indicating results saved disk file.dir optional directory save /retrieve data","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetSMNData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Meteorological data This function is defunct. — GetSMNData","text":"Nothing","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":null,"dir":"Reference","previous_headings":"","what":"Get topographic data — GetTopography","title":"Get topographic data — GetTopography","text":"Retrieves topographic data ETOPO1 Global Relief Model (see references).","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get topographic data — GetTopography","text":"","code":"GetTopography(   lon.west,   lon.east,   lat.north,   lat.south,   resolution = 3.5,   cache = TRUE,   file.dir = tempdir(),   verbose = interactive() )"},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get topographic data — GetTopography","text":"lon.west, lon.east, lat.north, lat.south latitudes longitudes bounding box degrees resolution numeric vector indicating desired resolution (degrees) lon lat directions (maximum resolution 1 minute) cache logical indicating results saved disk file.dir optional directory save /retrieve data verbose logical indicating whether print progress","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get topographic data — GetTopography","text":"data table height (meters) longitude latitude.","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get topographic data — GetTopography","text":"large requests can take long can denied NOAA server. function fails, try smaller bounding box coarser resolution. Longitude coordinates must 0 360.","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get topographic data — GetTopography","text":"Source: Amante, C. B.W. Eakins, 2009. ETOPO1 1 Arc-Minute Global Relief Model: Procedures, Data Sources Analysis. NOAA Technical Memorandum NESDIS NGDC-24. National Geophysical Data Center, NOAA.  doi:10.7289/V5C8276M","code":""},{"path":"https://eliocamp.github.io/metR/reference/GetTopography.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get topographic data — GetTopography","text":"","code":"if (FALSE) { # \\dontrun{ topo <- GetTopography(280, 330, 0, -60, resolution = 0.5) library(ggplot2) ggplot(topo, aes(lon, lat)) +     geom_raster(aes(fill = h)) +     geom_contour(aes(z = h), breaks = 0, color = \"black\", size = 0.3) +     scale_fill_gradient2(low = \"steelblue\", high = \"goldenrod2\", mid = \"olivedrab\") +     coord_quickmap() } # }"},{"path":"https://eliocamp.github.io/metR/reference/Impute2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing values by linear or constant interpolation — Impute2D","title":"Impute missing values by linear or constant interpolation — Impute2D","text":"Provides methods (soft) imputation missing values.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Impute2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing values by linear or constant interpolation — Impute2D","text":"","code":"Impute2D(formula, data = NULL, method = \"interpolate\")"},{"path":"https://eliocamp.github.io/metR/reference/Impute2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing values by linear or constant interpolation — Impute2D","text":"formula formula indicating dependent independent variables (see Details) data optional data.frame data method \"interpolate\" interpolation, numeric constant imputation function takes vector returns number (like mean)","code":""},{"path":"https://eliocamp.github.io/metR/reference/Impute2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute missing values by linear or constant interpolation — Impute2D","text":"\"soft\" imputation imputed values supposed representative missing data just filling algorithms need complete data (particular, contouring). method used method = \"interpolate\" simple linear interpolation x y direction average result. imputation method used geom_contour_fill().","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing values — ImputeEOF","title":"Impute missing values — ImputeEOF","text":"Imputes missing values via Data Interpolating Empirical Orthogonal Functions (DINEOF).","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing values — ImputeEOF","text":"","code":"ImputeEOF(   formula,   max.eof = NULL,   data = NULL,   min.eof = 1,   tol = 0.01,   max.iter = 10000,   validation = NULL,   verbose = interactive() )"},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing values — ImputeEOF","text":"formula formula build matrix used SVD decomposition (see Details) max.eof, min.eof maximum minimum number singular values used imputation data data.frame tol tolerance used determining convergence max.iter maximum iterations allowed algorithm validation number points use cross-validation (defaults maximum 30 10% non NA points) verbose logical indicating whether print progress","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing values — ImputeEOF","text":"vector imputed values attributes eof, number singular values used final imputation; rmse, Root Mean Square Error estimated cross-validation.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute missing values — ImputeEOF","text":"Singular values can computed matrices formula denotes build matrix data. formula form VAR ~ LEFT | RIGHT (see Formula::Formula) VAR variable whose values populate matrix, LEFT represent variables used make rows RIGHT, columns matrix. Think like \"VAR function LEFT RIGHT\". Alternatively, value.var NULL, possible use (probably) familiar data.table::dcast formula interface. case, data must provided. data matrix, formula argument ignored function returns matrix.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impute missing values — ImputeEOF","text":"Beckers, J.-M., Barth, ., Alvera-Azcárate, .: DINEOF reconstruction clouded images including error maps – application Sea-Surface Temperature around Corsican Island, Ocean Sci., 2, 183-199, doi:10.5194/os-2-183-2006 , 2006.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ImputeEOF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute missing values — ImputeEOF","text":"","code":"library(data.table) data(geopotential) geopotential <- copy(geopotential) geopotential[, gh.t := Anomaly(gh), by = .(lat, lon, month(date))] #>           lon   lat   lev       gh       date       gh.t #>         <num> <num> <int>    <num>     <Date>      <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01  -3.978597 #>      2:   2.5 -22.5   700 3162.516 1990-01-01  -3.736613 #>      3:   5.0 -22.5   700 3162.226 1990-01-01  -2.978516 #>      4:   7.5 -22.5   700 3162.323 1990-01-01  -2.500081 #>      5:  10.0 -22.5   700 3163.097 1990-01-01  -2.150594 #>     ---                                                  #> 290300: 347.5 -90.0   700 2671.484 1995-12-01 -18.526896 #> 290301: 350.0 -90.0   700 2671.484 1995-12-01 -18.526896 #> 290302: 352.5 -90.0   700 2671.484 1995-12-01 -18.526896 #> 290303: 355.0 -90.0   700 2671.484 1995-12-01 -18.526896 #> 290304: 357.5 -90.0   700 2671.484 1995-12-01 -18.526896  # Add gaps to field geopotential[, gh.gap := gh.t] #>           lon   lat   lev       gh       date       gh.t     gh.gap #>         <num> <num> <int>    <num>     <Date>      <num>      <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01  -3.978597  -3.978597 #>      2:   2.5 -22.5   700 3162.516 1990-01-01  -3.736613  -3.736613 #>      3:   5.0 -22.5   700 3162.226 1990-01-01  -2.978516  -2.978516 #>      4:   7.5 -22.5   700 3162.323 1990-01-01  -2.500081  -2.500081 #>      5:  10.0 -22.5   700 3163.097 1990-01-01  -2.150594  -2.150594 #>     ---                                                             #> 290300: 347.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290301: 350.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290302: 352.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290303: 355.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290304: 357.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 set.seed(42) geopotential[sample(1:.N, .N*0.3), gh.gap := NA] #>           lon   lat   lev       gh       date       gh.t     gh.gap #>         <num> <num> <int>    <num>     <Date>      <num>      <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01  -3.978597         NA #>      2:   2.5 -22.5   700 3162.516 1990-01-01  -3.736613  -3.736613 #>      3:   5.0 -22.5   700 3162.226 1990-01-01  -2.978516  -2.978516 #>      4:   7.5 -22.5   700 3162.323 1990-01-01  -2.500081  -2.500081 #>      5:  10.0 -22.5   700 3163.097 1990-01-01  -2.150594  -2.150594 #>     ---                                                             #> 290300: 347.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290301: 350.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290302: 352.5 -90.0   700 2671.484 1995-12-01 -18.526896         NA #> 290303: 355.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 #> 290304: 357.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896  max.eof <- 5    # change to a higher value geopotential[, gh.impute := ImputeEOF(gh.gap ~ lat + lon | date, max.eof,                                       verbose = TRUE, max.iter = 2000)] #> With 1 eof  - rmse = 27.147 #> With 2 eofs - rmse = 25.139 #> With 3 eofs - rmse = 23.658 #> With 4 eofs - rmse = 22.264 #> With 5 eofs - rmse = 21.105 #>           lon   lat   lev       gh       date       gh.t     gh.gap  gh.impute #>         <num> <num> <int>    <num>     <Date>      <num>      <num>      <num> #>      1:   0.0 -22.5   700 3163.839 1990-01-01  -3.978597         NA   1.214005 #>      2:   2.5 -22.5   700 3162.516 1990-01-01  -3.736613  -3.736613  -3.736613 #>      3:   5.0 -22.5   700 3162.226 1990-01-01  -2.978516  -2.978516  -2.978516 #>      4:   7.5 -22.5   700 3162.323 1990-01-01  -2.500081  -2.500081  -2.500081 #>      5:  10.0 -22.5   700 3163.097 1990-01-01  -2.150594  -2.150594  -2.150594 #>     ---                                                                        #> 290300: 347.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 -18.526896 #> 290301: 350.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 -18.526896 #> 290302: 352.5 -90.0   700 2671.484 1995-12-01 -18.526896         NA -26.276939 #> 290303: 355.0 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 -18.526896 #> 290304: 357.5 -90.0   700 2671.484 1995-12-01 -18.526896 -18.526896 -18.526896  library(ggplot2) ggplot(geopotential[date == date[1]], aes(lon, lat)) +     geom_contour(aes(z = gh.t), color = \"black\") +     geom_contour(aes(z = gh.impute))   # Scatterplot with a sample. na.sample <- geopotential[is.na(gh.gap)][sample(1:.N, .N*0.1)] ggplot(na.sample, aes(gh.t, gh.impute)) +     geom_point()   # Estimated RMSE attr(geopotential$gh.impute, \"rmse\") #> [1] 21.10459 # Real RMSE geopotential[is.na(gh.gap), sqrt(mean((gh.t - gh.impute)^2))] #> [1] 20.95526"},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":null,"dir":"Reference","previous_headings":"","what":"Bilinear interpolation — Interpolate","title":"Bilinear interpolation — Interpolate","text":"Interpolates values using bilinear interpolation.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bilinear interpolation — Interpolate","text":"","code":"Interpolate(formula, x.out, y.out, data = NULL, grid = TRUE, path = FALSE)"},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bilinear interpolation — Interpolate","text":"formula formula indicating dependent independent variables (see Details) x., y.x y values interpolate (see Details) data optional data.frame data grid logical indicating x.y.define regular grid. path logical character indicating x.y.define path. character, name column returning order said path.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bilinear interpolation — Interpolate","text":"data.frame interpolated values locations","code":""},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bilinear interpolation — Interpolate","text":"formula must form VAR1 | VAR2 ~ X + Y VAR1, VAR2, etc... names variables interpolate X Y names x y values, respectively. also possible pass values x, case, regular linear interpolation performed y., exists, ignored warning. grid = TRUE, x.y.must define values regular grid. grid = FALSE, define locations interpolate. grid path set TRUE value path takes precedence. x.can list, case, first two elements interpreted x y values interpolate can also path element used place path argument. helps creating path .path (see Examples)","code":""},{"path":"https://eliocamp.github.io/metR/reference/Interpolate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bilinear interpolation — Interpolate","text":"","code":"library(data.table) data(geopotential) geopotential <- geopotential[date == date[1]] # new grid x.out <- seq(0, 360, by = 10) y.out <- seq(-90, 0, by = 10)  # Interpolate values to a new grid interpolated <- geopotential[, Interpolate(gh ~ lon + lat, x.out, y.out)]  # Add values to an existing grid geopotential[, gh.new := Interpolate(gh ~ lon + lat, lon, lat,                                      data = interpolated, grid = FALSE)$gh] #>         lon   lat   lev       gh       date   gh.new #>       <num> <num> <int>    <num>     <Date>    <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01       NA #>    2:   2.5 -22.5   700 3162.516 1990-01-01       NA #>    3:   5.0 -22.5   700 3162.226 1990-01-01       NA #>    4:   7.5 -22.5   700 3162.323 1990-01-01       NA #>    5:  10.0 -22.5   700 3163.097 1990-01-01       NA #>   ---                                                #> 4028: 347.5 -90.0   700 2715.936 1990-01-01 2715.936 #> 4029: 350.0 -90.0   700 2715.936 1990-01-01       NA #> 4030: 352.5 -90.0   700 2715.936 1990-01-01       NA #> 4031: 355.0 -90.0   700 2715.936 1990-01-01       NA #> 4032: 357.5 -90.0   700 2715.936 1990-01-01       NA  # Interpolate multiple values geopotential[, c(\"u\", \"v\") := GeostrophicWind(gh, lon, lat)] #>         lon   lat   lev       gh       date   gh.new     u           v #>       <num> <num> <int>    <num>     <Date>    <num> <num>       <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01       NA    NA  1.08181190 #>    2:   2.5 -22.5   700 3162.516 1990-01-01       NA    NA  0.55189199 #>    3:   5.0 -22.5   700 3162.226 1990-01-01       NA    NA  0.06625043 #>    4:   7.5 -22.5   700 3162.323 1990-01-01       NA    NA -0.29800162 #>    5:  10.0 -22.5   700 3163.097 1990-01-01       NA    NA -0.75064329 #>   ---                                                                  #> 4028: 347.5 -90.0   700 2715.936 1990-01-01 2715.936    NA  0.00000000 #> 4029: 350.0 -90.0   700 2715.936 1990-01-01       NA    NA  0.00000000 #> 4030: 352.5 -90.0   700 2715.936 1990-01-01       NA    NA  0.00000000 #> 4031: 355.0 -90.0   700 2715.936 1990-01-01       NA    NA  0.00000000 #> 4032: 357.5 -90.0   700 2715.936 1990-01-01       NA    NA  0.00000000 interpolated <- geopotential[, Interpolate(u | v ~ lon + lat, x.out, y.out)]  # Interpolate values following a path lats <- c(-34, -54, -30)   # start and end latitudes lons <- c(302, 290, 180)   # start and end longituded path <- geopotential[, Interpolate(gh ~ lon + lat, as.path(lons, lats))]"},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":null,"dir":"Reference","previous_headings":"","what":"Skip observations — JumpBy","title":"Skip observations — JumpBy","text":"Skip observations","code":""},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skip observations — JumpBy","text":"","code":"JumpBy(x, by, start = 1, fill = NULL)"},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Skip observations — JumpBy","text":"x vector numeric interval elements keep start index start fill observations skipped","code":""},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Skip observations — JumpBy","text":"vector class x , fill null, length.","code":""},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skip observations — JumpBy","text":"Mostly useful labelling every byth element.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/JumpBy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skip observations — JumpBy","text":"","code":"x <- 1:50 JumpBy(x, 2)   # only odd numbers #>  [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 JumpBy(x, 2, start = 2)   # only even numbers #>  [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 JumpBy(x, 2, fill = NA)   # even numbers replaced by NA #>  [1]  1 NA  3 NA  5 NA  7 NA  9 NA 11 NA 13 NA 15 NA 17 NA 19 NA 21 NA 23 NA 25 #> [26] NA 27 NA 29 NA 31 NA 33 NA 35 NA 37 NA 39 NA 41 NA 43 NA 45 NA 47 NA 49 NA JumpBy(x, 2, fill = 6)   # even numbers replaced by 6 #>  [1]  1  6  3  6  5  6  7  6  9  6 11  6 13  6 15  6 17  6 19  6 21  6 23  6 25 #> [26]  6 27  6 29  6 31  6 33  6 35  6 37  6 39  6 41  6 43  6 45  6 47  6 49  6"},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":null,"dir":"Reference","previous_headings":"","what":"Magnitude and angle of a vector — Mag","title":"Magnitude and angle of a vector — Mag","text":"Computes magnitude vector dimension. angle (degrees) 2 dimensions.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magnitude and angle of a vector — Mag","text":"","code":"Mag(...)  Angle(x, y)"},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magnitude and angle of a vector — Mag","text":"... numeric vectors coordinates list coordinates x, y, x y directions vector","code":""},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magnitude and angle of a vector — Mag","text":"Mag: numeric vector length element ... \\(\\sqrt(x^2 + y^2 + ...)\\). Angle: numeric vector length x y atan2(y, x)*180/pi.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magnitude and angle of a vector — Mag","text":"Helpful save keystrokes gain readability computing wind (vector quantity) magnitude.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/Mag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magnitude and angle of a vector — Mag","text":"","code":"Mag(10, 10) #> [1] 14.14214 Angle(10, 10) #> [1] 45 Mag(10, 10, 10, 10) #> [1] 20 Mag(list(10, 10, 10, 10)) #> [1] 20  # There's no vector recicling! if (FALSE) { # \\dontrun{ Mag(1, 1:2) } # }"},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions for making breaks — MakeBreaks","title":"Functions for making breaks — MakeBreaks","text":"Functions return functions suitable use breaks argument ggplot2's continuous scales geom_contour_fill.","code":""},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions for making breaks — MakeBreaks","text":"","code":"MakeBreaks(binwidth = NULL, bins = 10, exclude = NULL)  AnchorBreaks(anchor = 0, binwidth = NULL, exclude = NULL, bins = 10)"},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions for making breaks — MakeBreaks","text":"binwidth width breaks bins number bins, used binwidth = NULL exclude vector breaks exclude anchor anchor value","code":""},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions for making breaks — MakeBreaks","text":"function takes range argument binwidth optional argument returns sequence equally spaced intervals covering range.","code":""},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions for making breaks — MakeBreaks","text":"MakeBreaks essentially export default way ggplot2::stat_contour makes breaks. AnchorBreaks makes breaks starting anchor value covering range data according binwidth.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/MakeBreaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions for making breaks — MakeBreaks","text":"","code":"my_breaks <- MakeBreaks(10) my_breaks(c(1, 100)) #>  [1]   0  10  20  30  40  50  60  70  80  90 100 my_breaks(c(1, 100), 20)    # optional new binwidth argument ignored #>  [1]   0  10  20  30  40  50  60  70  80  90 100  MakeBreaks()(c(1, 100), 20)  # but is not ignored if initial binwidth is NULL #> [1]   0  20  40  60  80 100 # One to one mapping between contours and breaks library(ggplot2) binwidth <- 20 ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +     geom_contour(aes(color = after_stat(level)), binwidth = binwidth) +     scale_color_continuous(breaks = MakeBreaks(binwidth))   #Two ways of getting the same contours. Better use the second one. ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +     geom_contour2(aes(color = after_stat(level)), breaks = AnchorBreaks(132),                   binwidth = binwidth) +     geom_contour2(aes(color = after_stat(level)), breaks = AnchorBreaks(132, binwidth)) +     scale_color_continuous(breaks = AnchorBreaks(132, binwidth))"},{"path":"https://eliocamp.github.io/metR/reference/MaskLand.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask — MaskLand","title":"Mask — MaskLand","text":"Creates  mask","code":""},{"path":"https://eliocamp.github.io/metR/reference/MaskLand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask — MaskLand","text":"","code":"MaskLand(lon, lat, mask = \"world\", wrap = c(0, 360))"},{"path":"https://eliocamp.github.io/metR/reference/MaskLand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask — MaskLand","text":"lon vector longitudes degrees 0-360 format lat vector latitudes degrees mask name dataset (load map) creating mask wrap longitude range used global mask","code":""},{"path":"https://eliocamp.github.io/metR/reference/MaskLand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask — MaskLand","text":"logical vector length lat lon TRUE means point inside one polygons making map. global map (default), means point land.","code":""},{"path":"https://eliocamp.github.io/metR/reference/MaskLand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask — MaskLand","text":"","code":"# Make a sea-land mask mask <- temperature[lev == 1000, .(lon = lon, lat = lat, land = MaskLand(lon, lat))] temperature <- temperature[mask, on = c(\"lon\", \"lat\")] library(ggplot2)  ggplot(mask, aes(lon, lat)) +    geom_raster(aes(fill = land))   # Take the temperature difference between land and ocean diftemp <- temperature[,           .(tempdif = mean(air[land == TRUE]) - mean(air[land == FALSE])),            by = .(lat, lev)]  ggplot(diftemp, aes(lat, lev)) +     geom_contour(aes(z = tempdif, color = after_stat(level))) +     scale_y_level() +     scale_x_latitude() +     scale_color_divergent() #> Warning: Removed 136 rows containing non-finite outside the scale range #> (`stat_contour()`)."},{"path":"https://eliocamp.github.io/metR/reference/Percentile.html","id":null,"dir":"Reference","previous_headings":"","what":"Percentiles — Percentile","title":"Percentiles — Percentile","text":"Computes percentiles.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Percentile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Percentiles — Percentile","text":"","code":"Percentile(x)"},{"path":"https://eliocamp.github.io/metR/reference/Percentile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Percentiles — Percentile","text":"x numeric vector","code":""},{"path":"https://eliocamp.github.io/metR/reference/Percentile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Percentiles — Percentile","text":"numeric vector length x percentile value x.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/Percentile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Percentiles — Percentile","text":"","code":"x <- rnorm(100) p <- Percentile(x)"},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Read NetCDF files. — ReadNetCDF","title":"Read NetCDF files. — ReadNetCDF","text":"Using ncdf4-package package, reads NetCDF file. advantage using ncvar_get output tidy data.table proper dimensions.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read NetCDF files. — ReadNetCDF","text":"","code":"ReadNetCDF(   file,   vars = NULL,   out = c(\"data.frame\", \"vector\", \"array\"),   subset = NULL,   key = FALSE )  ParseNetCDFtime(time)  OpenNetCDF(files)  GlanceNetCDF(file, ...)"},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read NetCDF files. — ReadNetCDF","text":"file source read . Must one : string representing local file(s) read access. string representing URL readable ncdf4::nc_open(). (includes DAP urls). netcdf object returned ncdf4::nc_open() list . (Use OpenNetCDF() sa helper function.) vars one : NULL: reads variables. character vector name variables read. function takes vector variables returns either character vector name variables read numeric/logical vector indicates subset variables. character indicating type output desired subset list subsetting objects. See . key TRUE, returns data.table keyed dimensions data. time time definition. Can accessed using GlanceNetCDF. files vector files open. ... GlanceNetCDF(), ignored. convenience call ReadNetCDF() can also valid GlanceNetCDF().","code":""},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read NetCDF files. — ReadNetCDF","text":"return format specified . can data table column variable row, observation; array named dimensions; vector. Since possible return multiple arrays vectors (one variable), consistency return type always list. Either two options much faster first since time consuming part melting array returned ncdf4::ncvar_get. = \"vector\" particularly useful adding new variables existing data frame dimensions. variables specified vars number dimensions, shorter variables recycled. E.g. reading 3D pressure field 2D surface temperature field, latter turned 3D field values missing dimension. GlanceNetCDF() returns list variables dimensions included file nice printing method.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"multifle-datasets","dir":"Reference","previous_headings":"","what":"Multifle datasets","title":"Read NetCDF files. — ReadNetCDF","text":"ReadNetCDF() rudimentary support multifile datasets. file argument vector files, function applied arguments using furrr::future_map() result concatenated.` Array output supported case, since clear result combined. file data included subset, read (metadata need processed). read multiple times multifle dataset, using OpenNetCDF() first open connections might speed things . Still, now coordinates read parsed every time, process can slow dataset large number files.","code":""},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"subsetting","dir":"Reference","previous_headings":"","what":"Subsetting","title":"Read NetCDF files. — ReadNetCDF","text":"basic form, subset named list whose names must match dimensions specified NetCDF file element must vector whose range defines contiguous subset data. need provide exact range matches actual gridpoints file; closest gridpoint selected. Furthermore, can use NA refer existing minimum maximum. , want get Southern Hemisphere data file defines latitude lat, can use: use dimension indices instead values, wrap expression base::(). example read first 10 timesteps file: Negative indices interpreted starting end. read last 10 timesteps file: complex subsetting operations supported. want read non-contiguous chunks data, can specify chunk list inside subset. example subset return two contiguous chunks: one South-West corner one North-East corner. Alternatively, want get four corners combination two conditions, operations can mixed together. example returns one spatial chunk two temporal chunks. general idea named elements define 'global' subsets ranges applied every subset, unnamed element define one contiguous chunk. example, time defines two temporal ranges every subset data . example, , equivalent demands much less typing.","code":"subset = list(lat = -90:0) subset = list(time = I(1, 10)) subset = list(time = I(-10, 0)) subset = list(list(lat = -90:-70, lon = 0:60),               list(lat = 70:90, lon = 300:360)) subset = list(lat = list(-90:-70, 70:90),               lon = list(0:60, 300:360)) subset = list(list(lat = -90:-70,                    lon = 0:60),               time = list(c(\"2000-01-01\", \"2000-12-31\"),                           c(\"2010-01-01\", \"2010-12-31\"))) subset = list(list(lat = -90:-70,                    lon = 0:60,                    time = c(\"2000-01-01\", \"2000-12-31\")),               list(lat = -90:-70,                    lon = 0:60,                    time = c(\"2010-01-01\", \"2010-12-31\")))"},{"path":"https://eliocamp.github.io/metR/reference/ReadNetCDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read NetCDF files. — ReadNetCDF","text":"","code":"file <- system.file(\"extdata\", \"temperature.nc\", package = \"metR\") # Get a list of variables. variables <- GlanceNetCDF(file) print(variables) #> ----- Variables -----  #> air: #>     mean Daily Air temperature in degK #>     Dimensions: lon by lat by level by time #>  #>  #> ----- Dimensions -----  #>   time: 1 values from 2010-07-09 to 2010-07-09  #>   level: 17 values from 10 to 1000 millibar #>   lat: 73 values from -90 to 90 degrees_north #>   lon: 144 values from 0 to 357.5 degrees_east  # The object returned by GlanceNetCDF is a list with lots # of information str(variables) #> List of 2 #>  $ vars:List of 1 #>   ..$ air:List of 22 #>   .. ..$ id                :List of 5 #>   .. .. ..$ id         : num 0 #>   .. .. ..$ group_index: num -1 #>   .. .. ..$ group_id   : int 65536 #>   .. .. ..$ list_index : num 1 #>   .. .. ..$ isdimvar   : logi FALSE #>   .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. ..$ name              : chr \"air\" #>   .. ..$ ndims             : int 4 #>   .. ..$ natts             : int 14 #>   .. ..$ size              : int [1:4] 144 73 17 1 #>   .. ..$ dimids            : int [1:4] 3 2 1 0 #>   .. ..$ prec              : chr \"float\" #>   .. ..$ units             : chr \"degK\" #>   .. ..$ longname          : chr \"mean Daily Air temperature\" #>   .. ..$ group_index       : int 1 #>   .. ..$ chunksizes        : int [1:4] 144 73 17 1 #>   .. ..$ storage           : num 2 #>   .. ..$ shuffle           : int 1 #>   .. ..$ compression       : int 2 #>   .. ..$ dims              : list() #>   .. ..$ dim               :List of 4 #>   .. .. ..$ :List of 10 #>   .. .. .. ..$ name         : chr \"lon\" #>   .. .. .. ..$ len          : int 144 #>   .. .. .. ..$ unlim        : logi FALSE #>   .. .. .. ..$ group_index  : int 1 #>   .. .. .. ..$ group_id     : int 65536 #>   .. .. .. ..$ id           : int 3 #>   .. .. .. ..$ dimvarid     :List of 5 #>   .. .. .. .. ..$ id         : int 3 #>   .. .. .. .. ..$ group_index: int 1 #>   .. .. .. .. ..$ group_id   : int 65536 #>   .. .. .. .. ..$ list_index : num -1 #>   .. .. .. .. ..$ isdimvar   : logi TRUE #>   .. .. .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. .. .. ..$ units        : chr \"degrees_east\" #>   .. .. .. ..$ vals         : num [1:144(1d)] 0 2.5 5 7.5 10 12.5 15 17.5 20 22.5 ... #>   .. .. .. ..$ create_dimvar: logi TRUE #>   .. .. .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   .. .. ..$ :List of 10 #>   .. .. .. ..$ name         : chr \"lat\" #>   .. .. .. ..$ len          : int 73 #>   .. .. .. ..$ unlim        : logi FALSE #>   .. .. .. ..$ group_index  : int 1 #>   .. .. .. ..$ group_id     : int 65536 #>   .. .. .. ..$ id           : int 2 #>   .. .. .. ..$ dimvarid     :List of 5 #>   .. .. .. .. ..$ id         : int 1 #>   .. .. .. .. ..$ group_index: int 1 #>   .. .. .. .. ..$ group_id   : int 65536 #>   .. .. .. .. ..$ list_index : num -1 #>   .. .. .. .. ..$ isdimvar   : logi TRUE #>   .. .. .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. .. .. ..$ units        : chr \"degrees_north\" #>   .. .. .. ..$ vals         : num [1:73(1d)] 90 87.5 85 82.5 80 77.5 75 72.5 70 67.5 ... #>   .. .. .. ..$ create_dimvar: logi TRUE #>   .. .. .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   .. .. ..$ :List of 10 #>   .. .. .. ..$ name         : chr \"level\" #>   .. .. .. ..$ len          : int 17 #>   .. .. .. ..$ unlim        : logi FALSE #>   .. .. .. ..$ group_index  : int 1 #>   .. .. .. ..$ group_id     : int 65536 #>   .. .. .. ..$ id           : int 1 #>   .. .. .. ..$ dimvarid     :List of 5 #>   .. .. .. .. ..$ id         : int 2 #>   .. .. .. .. ..$ group_index: int 1 #>   .. .. .. .. ..$ group_id   : int 65536 #>   .. .. .. .. ..$ list_index : num -1 #>   .. .. .. .. ..$ isdimvar   : logi TRUE #>   .. .. .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. .. .. ..$ units        : chr \"millibar\" #>   .. .. .. ..$ vals         : num [1:17(1d)] 1000 925 850 700 600 500 400 300 250 200 ... #>   .. .. .. ..$ create_dimvar: logi TRUE #>   .. .. .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   .. .. ..$ :List of 10 #>   .. .. .. ..$ name         : chr \"time\" #>   .. .. .. ..$ len          : int 1 #>   .. .. .. ..$ unlim        : logi TRUE #>   .. .. .. ..$ group_index  : int 1 #>   .. .. .. ..$ group_id     : int 65536 #>   .. .. .. ..$ id           : int 0 #>   .. .. .. ..$ dimvarid     :List of 5 #>   .. .. .. .. ..$ id         : int 4 #>   .. .. .. .. ..$ group_index: int 1 #>   .. .. .. .. ..$ group_id   : int 65536 #>   .. .. .. .. ..$ list_index : num -1 #>   .. .. .. .. ..$ isdimvar   : logi TRUE #>   .. .. .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. .. .. ..$ units        : chr \"hours since 1800-01-01 00:00:0.0\" #>   .. .. .. ..$ vals         : num [1(1d)] 1845360 #>   .. .. .. ..$ create_dimvar: logi TRUE #>   .. .. .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   .. ..$ varsize           : int [1:4] 144 73 17 1 #>   .. ..$ unlim             : logi TRUE #>   .. ..$ make_missing_value: logi TRUE #>   .. ..$ missval           : num -9.97e+36 #>   .. ..$ hasAddOffset      : logi FALSE #>   .. ..$ hasScaleFact      : logi FALSE #>   .. ..- attr(*, \"class\")= chr \"ncvar4\" #>  $ dims:List of 4 #>   ..$ time :List of 10 #>   .. ..$ name         : chr \"time\" #>   .. ..$ len          : int 1 #>   .. ..$ unlim        : logi TRUE #>   .. ..$ group_index  : int 1 #>   .. ..$ group_id     : int 65536 #>   .. ..$ id           : int 0 #>   .. ..$ dimvarid     :List of 5 #>   .. .. ..$ id         : int 4 #>   .. .. ..$ group_index: int 1 #>   .. .. ..$ group_id   : int 65536 #>   .. .. ..$ list_index : num -1 #>   .. .. ..$ isdimvar   : logi TRUE #>   .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. ..$ units        : chr \"hours since 1800-01-01 00:00:0.0\" #>   .. ..$ vals         : num [1(1d)] 1845360 #>   .. ..$ create_dimvar: logi TRUE #>   .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   ..$ level:List of 10 #>   .. ..$ name         : chr \"level\" #>   .. ..$ len          : int 17 #>   .. ..$ unlim        : logi FALSE #>   .. ..$ group_index  : int 1 #>   .. ..$ group_id     : int 65536 #>   .. ..$ id           : int 1 #>   .. ..$ dimvarid     :List of 5 #>   .. .. ..$ id         : int 2 #>   .. .. ..$ group_index: int 1 #>   .. .. ..$ group_id   : int 65536 #>   .. .. ..$ list_index : num -1 #>   .. .. ..$ isdimvar   : logi TRUE #>   .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. ..$ units        : chr \"millibar\" #>   .. ..$ vals         : num [1:17(1d)] 1000 925 850 700 600 500 400 300 250 200 ... #>   .. ..$ create_dimvar: logi TRUE #>   .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   ..$ lat  :List of 10 #>   .. ..$ name         : chr \"lat\" #>   .. ..$ len          : int 73 #>   .. ..$ unlim        : logi FALSE #>   .. ..$ group_index  : int 1 #>   .. ..$ group_id     : int 65536 #>   .. ..$ id           : int 2 #>   .. ..$ dimvarid     :List of 5 #>   .. .. ..$ id         : int 1 #>   .. .. ..$ group_index: int 1 #>   .. .. ..$ group_id   : int 65536 #>   .. .. ..$ list_index : num -1 #>   .. .. ..$ isdimvar   : logi TRUE #>   .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. ..$ units        : chr \"degrees_north\" #>   .. ..$ vals         : num [1:73(1d)] 90 87.5 85 82.5 80 77.5 75 72.5 70 67.5 ... #>   .. ..$ create_dimvar: logi TRUE #>   .. ..- attr(*, \"class\")= chr \"ncdim4\" #>   ..$ lon  :List of 10 #>   .. ..$ name         : chr \"lon\" #>   .. ..$ len          : int 144 #>   .. ..$ unlim        : logi FALSE #>   .. ..$ group_index  : int 1 #>   .. ..$ group_id     : int 65536 #>   .. ..$ id           : int 3 #>   .. ..$ dimvarid     :List of 5 #>   .. .. ..$ id         : int 3 #>   .. .. ..$ group_index: int 1 #>   .. .. ..$ group_id   : int 65536 #>   .. .. ..$ list_index : num -1 #>   .. .. ..$ isdimvar   : logi TRUE #>   .. .. ..- attr(*, \"class\")= chr \"ncid4\" #>   .. ..$ units        : chr \"degrees_east\" #>   .. ..$ vals         : num [1:144(1d)] 0 2.5 5 7.5 10 12.5 15 17.5 20 22.5 ... #>   .. ..$ create_dimvar: logi TRUE #>   .. ..- attr(*, \"class\")= chr \"ncdim4\" #>  - attr(*, \"class\")= chr [1:2] \"nc_glance\" \"list\"  # Read only the first one, with name \"var\". field <- ReadNetCDF(file, vars = c(var = names(variables$vars[1]))) # Add a new variable. # ¡Make sure it's on the same exact grid! field[, var2 := ReadNetCDF(file, out = \"vector\")] #>               time level   lat   lon    var   var2 #>             <POSc> <num> <num> <num>  <num>  <num> #>      1: 2010-07-09  1000    90   0.0 274.87 274.87 #>      2: 2010-07-09  1000    90   2.5 274.87 274.87 #>      3: 2010-07-09  1000    90   5.0 274.87 274.87 #>      4: 2010-07-09  1000    90   7.5 274.87 274.87 #>      5: 2010-07-09  1000    90  10.0 274.87 274.87 #>     ---                                            #> 178700: 2010-07-09    10   -90 347.5 188.25 188.25 #> 178701: 2010-07-09    10   -90 350.0 188.25 188.25 #> 178702: 2010-07-09    10   -90 352.5 188.25 188.25 #> 178703: 2010-07-09    10   -90 355.0 188.25 188.25 #> 178704: 2010-07-09    10   -90 357.5 188.25 188.25  if (FALSE) { # \\dontrun{ # Using a DAP url url <- \"http://iridl.ldeo.columbia.edu/SOURCES/.Models/.SubX/.GMAO/.GEOS_V2p1/.hindcast/.ua/dods\" field <- ReadNetCDF(url, subset = list(M = 1,                                        P = 10,                                        S = \"1999-01-01\"))  # In this case, opening the netcdf file takes a non-neglible # amount of time. So if you want to iterate over many dimensions, # then it's more efficient to open the file first and then read it.  ncfile <- ncdf4::nc_open(url) field <- ReadNetCDF(ncfile, subset = list(M = 1,                                        P = 10,                                        S = \"1999-01-01\"))   # Using a function in `vars` to read all variables that # start with \"radar_\". ReadNetCDF(radar_file, vars = function(x) startsWith(x, \"radar_\"))  } # }"},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooths a 2D field — Smooth2D","title":"Smooths a 2D field — Smooth2D","text":"Smooth 2D field using user-supplied method.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooths a 2D field — Smooth2D","text":"","code":"Smooth2D(x, y, value, method = smooth_svd(0.01))  smooth_dct(kx = 0.5, ky = kx)  smooth_svd(variance_lost = 0.01)"},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooths a 2D field — Smooth2D","text":"x, y Vector x y coordinates value Vector values method method use smooth. Must function takes matrix returns smoothed matrix. Build-methods smooth_svd() smooth_dct(). kx, ky Proportion components keep x y direction respectively. Lower values increase smoothness. variance_lost Maximum percentage variance lost smoothing.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooths a 2D field — Smooth2D","text":"vector length value.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Smooths a 2D field — Smooth2D","text":"smooth_svd() computes SVD field reconstructs keeping leading values ensures maximum variance lost. smooth_dct() computes Discrete Cosine Transform field sets proportion components zero.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Smooth2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooths a 2D field — Smooth2D","text":"","code":"library(ggplot2) # Creates a noisy version of the volcano dataset and applies the smooth volcano <- reshape2::melt(datasets::volcano, value.name = \"original\") volcano$noisy <- with(volcano, original + 1.5*rnorm(length(original)))  volcano$smooth_svd <- with(volcano, Smooth2D(Var2, Var1, noisy, method = smooth_svd(0.005))) volcano$smooth_dct <- with(volcano, Smooth2D(Var2, Var1, noisy, method = smooth_dct(kx = 0.4)))  volcano <- reshape2::melt(volcano, id.vars = c(\"Var1\", \"Var2\"))  ggplot(volcano, aes(Var1, Var2)) +   geom_contour(aes(z = value, color = after_stat(level))) +   scale_color_viridis_c() +   coord_equal() +   facet_wrap(~variable, ncol = 2)"},{"path":"https://eliocamp.github.io/metR/reference/Trajectory.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute trajectories — Trajectory","title":"Compute trajectories — Trajectory","text":"Computes trajectories particles time-varying velocity field.","code":""},{"path":"https://eliocamp.github.io/metR/reference/Trajectory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute trajectories — Trajectory","text":"","code":"Trajectory(formula, x0, y0, cyclical = FALSE, data = NULL, res = 2)"},{"path":"https://eliocamp.github.io/metR/reference/Trajectory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute trajectories — Trajectory","text":"formula formula indicating dependent independent variables form dx + dy ~ x + y + t. x0, y0 starting coordinates particles. cyclical logical vector boundary condition x y. data optional data.frame containing variables. res resolution parameter (higher numbers increases resolution)","code":""},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate wave-activity flux — WaveFlux","title":"Calculate wave-activity flux — WaveFlux","text":"Calculate wave-activity flux","code":""},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate wave-activity flux — WaveFlux","text":"","code":"WaveFlux(gh, u, v, lon, lat, lev, g = 9.81, a = 6371000)"},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate wave-activity flux — WaveFlux","text":"gh geopotential height u mean zonal velocity v mean meridional velocity lon longitude (degrees) lat latitude (degrees) lev pressure level (hPa) g acceleration gravity Earth's radius","code":""},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate wave-activity flux — WaveFlux","text":"list elements: longitude, latitude, two horizontal components wave activity flux.","code":""},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate wave-activity flux — WaveFlux","text":"Calculates Plum-like wave activity fluxes","code":""},{"path":"https://eliocamp.github.io/metR/reference/WaveFlux.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate wave-activity flux — WaveFlux","text":"Takaya, K. H. Nakamura, 2001: Formulation Phase-Independent Wave-Activity Flux Stationary Migratory Quasigeostrophic Eddies Zonally Varying Basic Flow. J. Atmos. Sci., 58, 608–627, doi:10.1175/1520-0469(2001)058<0608:AFOAPI>2.0.CO;2   Adapted https://github.com/marisolosman/Reunion_Clima/blob/master/WAF/Calculo_WAF.ipynb","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/WrapCircular.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap periodic data to any range — WrapCircular","title":"Wrap periodic data to any range — WrapCircular","text":"Periodic data can defined one period extended arbitrary range.","code":""},{"path":"https://eliocamp.github.io/metR/reference/WrapCircular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap periodic data to any range — WrapCircular","text":"","code":"WrapCircular(x, circular = \"lon\", wrap = c(0, 360))"},{"path":"https://eliocamp.github.io/metR/reference/WrapCircular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap periodic data to any range — WrapCircular","text":"x data.frame circular name circular dimension wrap wrap data extended ","code":""},{"path":"https://eliocamp.github.io/metR/reference/WrapCircular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap periodic data to any range — WrapCircular","text":"data.frame.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/WrapCircular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap periodic data to any range — WrapCircular","text":"","code":"library(ggplot2) library(data.table) data(geopotential) g <- ggplot(geopotential[date == date[1]], aes(lon, lat)) +     geom_contour(aes(z = gh)) +     coord_polar() +     ylim(c(-90, -10))  # This plot has problems in lon = 0 g   # But using WrapCircular solves it. g %+% WrapCircular(geopotential[date == date[1]], \"lon\", c(0, 360)) #> Warning: <ggplot> %+% x was deprecated in ggplot2 4.0.0. #> ℹ Please use <ggplot> + x instead. #> Warning: 'WrapCircular' is deprecated, use ggperiodic::wrap instead.   # Aditionally data can be just repeatet to the right and # left ggplot(WrapCircular(geopotential[date == date[1]], wrap = c(-180, 360 + 180)),        aes(lon, lat)) +     geom_contour(aes(z = gh)) #> Warning: 'WrapCircular' is deprecated, use ggperiodic::wrap instead.   # The same behaviour is now implemented directly in geom_contour2 # and geom_contour_fill ggplot(geopotential[date == date[1]], aes(lon, lat)) +     geom_contour2(aes(z = gh), xwrap = c(-180, 360 + 180)) #> Warning: 'xwrap' and 'ywrap' will be deprecated. Use ggperiodic::periodic insead."},{"path":"https://eliocamp.github.io/metR/reference/as.path.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolates between locations — as.path","title":"Interpolates between locations — as.path","text":"helper function quickly make interpolated list locations number locations","code":""},{"path":"https://eliocamp.github.io/metR/reference/as.path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolates between locations — as.path","text":"","code":"as.path(x, y, n = 10, path = TRUE)"},{"path":"https://eliocamp.github.io/metR/reference/as.path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolates between locations — as.path","text":"x, y numeric vectors x y locations. one length 1, recycled. n number points interpolate path either TRUE character vector name path.","code":""},{"path":"https://eliocamp.github.io/metR/reference/as.path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolates between locations — as.path","text":"list components x y list locations path arguments","code":""},{"path":"https://eliocamp.github.io/metR/reference/as.path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpolates between locations — as.path","text":"function mostly useful combined Interpolate","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/coriolis.html","id":null,"dir":"Reference","previous_headings":"","what":"Effects of the Earth's rotation — coriolis","title":"Effects of the Earth's rotation — coriolis","text":"Coriolis beta parameters latitude.","code":""},{"path":"https://eliocamp.github.io/metR/reference/coriolis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effects of the Earth's rotation — coriolis","text":"","code":"coriolis(lat)  f(lat)  coriolis.dy(lat, a = 6371000)  f.dy(lat, a = 6371000)"},{"path":"https://eliocamp.github.io/metR/reference/coriolis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effects of the Earth's rotation — coriolis","text":"lat latitude degrees radius earth","code":""},{"path":"https://eliocamp.github.io/metR/reference/coriolis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Effects of the Earth's rotation — coriolis","text":"functions use correct sidereal day (24hs 56mins 4.091s) instead incorrect solar day (24hs) 0.3\\ pedantry.","code":""},{"path":"https://eliocamp.github.io/metR/reference/cut.eof.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove some principal components. — cut.eof","title":"Remove some principal components. — cut.eof","text":"Returns eof object just n principal components.","code":""},{"path":"https://eliocamp.github.io/metR/reference/cut.eof.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove some principal components. — cut.eof","text":"","code":"# S3 method for class 'eof' cut(x, n, ...)"},{"path":"https://eliocamp.github.io/metR/reference/cut.eof.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove some principal components. — cut.eof","text":"x eof object n eofs keep ... arguments passed methods","code":""},{"path":"https://eliocamp.github.io/metR/reference/denormalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Denormalise eof matrices — denormalise","title":"Denormalise eof matrices — denormalise","text":"matrices returned EOF() normalized. function multiplies left right matrix diagonal matrix return proper units.","code":""},{"path":"https://eliocamp.github.io/metR/reference/denormalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Denormalise eof matrices — denormalise","text":"","code":"denormalise(eof, which = c(\"left\", \"right\"))  denormalize(eof, which = c(\"left\", \"right\"))"},{"path":"https://eliocamp.github.io/metR/reference/denormalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Denormalise eof matrices — denormalise","text":"eof eof object. side eof decomposition denormalise","code":""},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Create discretised versions of continuous scales — as.discretised_scale","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"scale allows ggplot understand data discretised procedure akin cut access underlying continuous values. scale opposite (take continuous data treat discrete) see ggplot2::binned_scale().","code":""},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"","code":"as.discretised_scale(scale_function)  scale_fill_discretised(   ...,   low = \"#132B43\",   high = \"#56B1F7\",   space = \"Lab\",   na.value = \"grey50\",   guide = ggplot2::guide_colorsteps(even.steps = FALSE, show.limits = TRUE),   aesthetics = \"fill\" )  scale_fill_divergent_discretised(   ...,   low = scales::muted(\"blue\"),   mid = \"white\",   high = scales::muted(\"red\"),   midpoint = 0,   space = \"Lab\",   na.value = \"grey50\",   guide = ggplot2::guide_colorsteps(even.steps = FALSE, show.limits = TRUE) )  discretised_scale(   aesthetics,   scale_name,   palette,   name = ggplot2::waiver(),   breaks = ggplot2::waiver(),   labels = ggplot2::waiver(),   limits = NULL,   trans = scales::identity_trans(),   na.value = NA,   drop = FALSE,   guide = ggplot2::guide_colorsteps(even.steps = FALSE),   position = \"left\",   rescaler = scales::rescale,   oob = scales::censor,   super = ScaleDiscretised )"},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"scale_function scale function (e.g. scale_fill_divergent) ... Arguments passed continuous_scale scale_name name scale used error messages associated scale. breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. minor_breaks One : NULL minor breaks waiver() default breaks (none discrete, one minor break major break continuous) numeric vector positions function given limits returns vector minor breaks. Also accepts rlang lambda function notation. function two arguments, given limits major break positions. n.breaks integer guiding number major breaks. algorithm may choose slightly different number ensure nice break labels. effect breaks = waiver(). Use NULL use default number breaks given transformation. labels One options . Please note labels vector, highly recommended also set breaks argument vector protect unintended mismatches. NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). rescaler function used scale input values range [0, 1]. always scales::rescale(), except diverging n colour gradients (.e., scale_colour_gradient2(), scale_colour_gradientn()). rescaler ignored position scales, always use scales::rescale(). Also accepts rlang lambda function notation. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. trans Deprecated favour transform. call call used construct scale reporting messages. super super class use constructed scale low, high Colours low high ends gradient. space colour space calculate gradient. Must \"Lab\" - values deprecated. na.value Colour use missing values guide Type legend. Use \"colourbar\" continuous colour bar, \"legend\" discrete colour legend. aesthetics Character string vector character strings listing name(s) aesthetic(s) scale works . can useful, example, apply colour settings colour fill aesthetics time, via aesthetics = c(\"colour\", \"fill\"). mid colour mid point midpoint midpoint (data value) diverging scale. Defaults 0. scale_name name scale used error messages associated scale. palette palette function called numeric vector values 0 1 returns corresponding output values (e.g., scales::pal_area()). name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. labels One options . Please note labels vector, highly recommended also set breaks argument vector protect unintended mismatches. NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). trans Deprecated favour transform. drop unused factor levels omitted scale? default, TRUE, uses levels appear data; FALSE uses levels factor. position position scales, position axis. left right y axes, top bottom x axes. rescaler function used scale input values range [0, 1]. always scales::rescale(), except diverging n colour gradients (.e., scale_colour_gradient2(), scale_colour_gradientn()). rescaler ignored position scales, always use scales::rescale(). Also accepts rlang lambda function notation. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. super super class use constructed scale","code":""},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"function arguments scale_function works discretised values.","code":""},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"scale makes easy synchronise breaks filled contours breaks shown colour guide. Bear mind using geom_contour_fill(), default fill aesthetic (level_mid) discretised. use scale geom, need set aes(fill = after_stat(level)).","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/discretised_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create discretised versions of continuous scales — as.discretised_scale","text":"","code":"library(ggplot2) scale_fill_brewer_discretised <- as.discretised_scale(scale_fill_distiller)   library(ggplot2)  # Using the `level` compute aesthetic from `geom_contour_fill()` # (or ggplot2::geom_contour_filled()), the default scale is discrete. # This means that you cannot map colours to the underlying numbers. v <- ggplot(faithfuld, aes(waiting, eruptions, z = density)) v + geom_contour_fill(aes(fill = after_stat(level)))   v + geom_contour_fill(aes(fill = after_stat(level))) +   scale_fill_discretised()   # The scale can be customised the same as any continuous colour scale v + geom_contour_fill(aes(fill = after_stat(level))) +   scale_fill_discretised(low = \"#a62100\", high = \"#fff394\")   # Setting limits explicitly will truncate the scale # (if any limit is inside the range of the breaks but doesn't # coincide with any range, it will be rounded with a warning) v + geom_contour_fill(aes(fill = after_stat(level))) +   scale_fill_discretised(low = \"#a62100\", high = \"#fff394\",                          limits = c(0.01, 0.028)) #> Warning: User supplied limits don't correspond to valid breaks. [0.01, 0.028] rounded to [0.01, 0.03]   # Or extend it. v + geom_contour_fill(aes(fill = after_stat(level))) +   scale_fill_discretised(low = \"#a62100\", high = \"#fff394\",                          limits = c(0, 0.07))   v + geom_contour_fill(aes(fill = after_stat(level))) +   scale_fill_divergent_discretised(midpoint = 0.02)   # Existing continous scales can be \"retrofitted\" by changing the `super` # and `guide` arguments. v + geom_contour_fill(aes(fill = after_stat(level))) +     scale_fill_distiller(super = ScaleDiscretised)   # Unequal breaks will, by default, map to unequal spacing in the guide v + geom_contour_fill(aes(fill = after_stat(level)), breaks = c(0, 0.005, 0.01, 0.02, 0.04)) +   scale_fill_discretised()   # You can change that by the `even.steps` argument on ggplot2::guide_colorsteps() v + geom_contour_fill(aes(fill = after_stat(level)), breaks = c(0, 0.005, 0.01, 0.02, 0.04)) +   scale_fill_discretised(guide = guide_colorsteps(even.steps = TRUE, show.limits = TRUE))"},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":null,"dir":"Reference","previous_headings":"","what":"Arrows — geom_arrow","title":"Arrows — geom_arrow","text":"Parametrization ggplot2::geom_segment either location displacement magnitude angle default arrows. geom_arrow() geom_vector() defaults preserving direction coordinate transformation different plot ratios.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arrows — geom_arrow","text":"","code":"geom_arrow(   mapping = NULL,   data = NULL,   stat = \"arrow\",   position = \"identity\",   ...,   start = 0,   direction = c(\"ccw\", \"cw\"),   pivot = 0.5,   preserve.dir = TRUE,   min.mag = 0,   skip = 0,   skip.x = skip,   skip.y = skip,   arrow.angle = 15,   arrow.length = 0.5,   arrow.ends = \"last\",   arrow.type = \"closed\",   arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, \"lines\"), ends = arrow.ends,     type = arrow.type),   lineend = \"butt\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_vector(   mapping = NULL,   data = NULL,   stat = \"arrow\",   position = \"identity\",   ...,   start = 0,   direction = c(\"ccw\", \"cw\"),   pivot = 0.5,   preserve.dir = FALSE,   min.mag = 0,   skip = 0,   skip.x = skip,   skip.y = skip,   arrow.angle = 15,   arrow.length = 0.5,   arrow.ends = \"last\",   arrow.type = \"closed\",   arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, \"lines\"), ends = arrow.ends,     type = arrow.type),   lineend = \"butt\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arrows — geom_arrow","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. start starting angle rotation degrees direction direction rotation (counter-clockwise clockwise) pivot numeric indicating pivot arrow 0 means beginning 1 means end. preserve.dir logical indicating whether preserve direction min.mag minimum magnitude plotting vectors skip, skip.x, skip.y numeric specifying number gridpoints draw x y direction arrow.length, arrow.angle, arrow.ends, arrow.type parameters passed grid::arrow arrow specification arrow heads, created grid::arrow(). lineend Line end style (round, butt, square). na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders().","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arrows — geom_arrow","text":"Direction start allows work different standards. meteorological standard, example, use star = -90 direction = \"cw\".","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Arrows — geom_arrow","text":"geom_vector understands following aesthetics (required aesthetics bold) x y either mag angle, dx dy alpha colour linetype size lineend","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_arrow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arrows — geom_arrow","text":"","code":"library(data.table) library(ggplot2)  data(seals) # If the velocity components are in the same units as the axis, # geom_vector() (or geom_arrow(preserve.dir = TRUE)) might be a better option ggplot(seals, aes(long, lat)) +     geom_arrow(aes(dx = delta_long, dy = delta_lat), skip = 1, color = \"red\") +     geom_vector(aes(dx = delta_long, dy = delta_lat), skip = 1) +     scale_mag()   data(geopotential) geopotential <- copy(geopotential)[date == date[1]] geopotential[, gh.z := Anomaly(gh), by = .(lat)] #>         lon   lat   lev       gh       date     gh.z #>       <num> <num> <int>    <num>     <Date>    <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01 13.67219 #>    2:   2.5 -22.5   700 3162.516 1990-01-01 12.34968 #>    3:   5.0 -22.5   700 3162.226 1990-01-01 12.05939 #>    4:   7.5 -22.5   700 3162.323 1990-01-01 12.15607 #>    5:  10.0 -22.5   700 3163.097 1990-01-01 12.93024 #>   ---                                                #> 4028: 347.5 -90.0   700 2715.936 1990-01-01  0.00000 #> 4029: 350.0 -90.0   700 2715.936 1990-01-01  0.00000 #> 4030: 352.5 -90.0   700 2715.936 1990-01-01  0.00000 #> 4031: 355.0 -90.0   700 2715.936 1990-01-01  0.00000 #> 4032: 357.5 -90.0   700 2715.936 1990-01-01  0.00000 geopotential[, c(\"u\", \"v\") := GeostrophicWind(gh.z, lon, lat)] #>         lon   lat   lev       gh       date     gh.z     u           v #>       <num> <num> <int>    <num>     <Date>    <num> <num>       <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01 13.67219    NA  1.08181190 #>    2:   2.5 -22.5   700 3162.516 1990-01-01 12.34968    NA  0.55189199 #>    3:   5.0 -22.5   700 3162.226 1990-01-01 12.05939    NA  0.06625043 #>    4:   7.5 -22.5   700 3162.323 1990-01-01 12.15607    NA -0.29800162 #>    5:  10.0 -22.5   700 3163.097 1990-01-01 12.93024    NA -0.75064329 #>   ---                                                                  #> 4028: 347.5 -90.0   700 2715.936 1990-01-01  0.00000    NA  0.00000000 #> 4029: 350.0 -90.0   700 2715.936 1990-01-01  0.00000    NA  0.00000000 #> 4030: 352.5 -90.0   700 2715.936 1990-01-01  0.00000    NA  0.00000000 #> 4031: 355.0 -90.0   700 2715.936 1990-01-01  0.00000    NA  0.00000000 #> 4032: 357.5 -90.0   700 2715.936 1990-01-01  0.00000    NA  0.00000000  (g <- ggplot(geopotential, aes(lon, lat)) +     geom_arrow(aes(dx = dlon(u, lat), dy = dlat(v)), skip.x = 3, skip.y = 2,                color = \"red\") +     geom_vector(aes(dx = dlon(u, lat), dy = dlat(v)), skip.x = 3, skip.y = 2) +     scale_mag( guide = \"none\"))   # A dramatic illustration of the difference between arrow and vector g + coord_polar()   # When plotting winds in a lat-lon grid, a good way to have both # the correct direction and an interpretable magnitude is to define # the angle by the longitud and latitude displacement and the magnitude # by the wind velocity. That way arrows are always parallel to streamlines # and their magnitude are in the correct units. ggplot(geopotential, aes(lon, lat)) +     geom_contour(aes(z = gh.z)) +     geom_vector(aes(angle = atan2(dlat(v), dlon(u, lat))*180/pi,                    mag = Mag(v, u)), skip = 1, pivot = 0.5) +     scale_mag()   # Sverdrup transport library(data.table) b <- 10 d <- 10 grid <- as.data.table(expand.grid(x = seq(1, d, by = 0.5),                                   y = seq(1, b, by = 0.5))) grid[, My := -sin(pi*y/b)*pi/b] #>          x     y            My #>      <num> <num>         <num> #>   1:   1.0     1 -9.708055e-02 #>   2:   1.5     1 -9.708055e-02 #>   3:   2.0     1 -9.708055e-02 #>   4:   2.5     1 -9.708055e-02 #>   5:   3.0     1 -9.708055e-02 #>  ---                           #> 357:   8.0    10 -3.847341e-17 #> 358:   8.5    10 -3.847341e-17 #> 359:   9.0    10 -3.847341e-17 #> 360:   9.5    10 -3.847341e-17 #> 361:  10.0    10 -3.847341e-17 grid[, Mx := -pi^2/b^2*cos(pi*y/b)*(d - x)] #>          x     y            My          Mx #>      <num> <num>         <num>       <num> #>   1:   1.0     1 -9.708055e-02 -0.84478964 #>   2:   1.5     1 -9.708055e-02 -0.79785688 #>   3:   2.0     1 -9.708055e-02 -0.75092413 #>   4:   2.5     1 -9.708055e-02 -0.70399137 #>   5:   3.0     1 -9.708055e-02 -0.65705861 #>  ---                                       #> 357:   8.0    10 -3.847341e-17  0.19739209 #> 358:   8.5    10 -3.847341e-17  0.14804407 #> 359:   9.0    10 -3.847341e-17  0.09869604 #> 360:   9.5    10 -3.847341e-17  0.04934802 #> 361:  10.0    10 -3.847341e-17  0.00000000  ggplot(grid, aes(x, y)) +     geom_arrow(aes(dx = Mx, dy = My))   # Due to limitations in ggplot2 (see: https://github.com/tidyverse/ggplot2/issues/4291), # if you define the vector with the dx and dy aesthetics, you need # to explicitly add scale_mag() in order to show the arrow legend.  ggplot(grid, aes(x, y)) +     geom_arrow(aes(dx = Mx, dy = My)) +     scale_mag()   # Alternative, use Mag and Angle. ggplot(grid, aes(x, y)) +     geom_arrow(aes(mag = Mag(Mx, My), angle = Angle(Mx, My)))"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":null,"dir":"Reference","previous_headings":"","what":"2d contours of a 3d surface — geom_contour2","title":"2d contours of a 3d surface — geom_contour2","text":"Similar ggplot2::geom_contour can label contour lines, accepts accepts function breaks argument computes breaks globally instead per panel.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"2d contours of a 3d surface — geom_contour2","text":"","code":"geom_contour2(   mapping = NULL,   data = NULL,   stat = \"contour2\",   position = \"identity\",   ...,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 1,   breaks = MakeBreaks(),   bins = NULL,   binwidth = NULL,   global.breaks = TRUE,   na.rm = FALSE,   na.fill = FALSE,   skip = 1,   margin = grid::unit(c(1, 1, 1, 1), \"pt\"),   label.placer = label_placer_flattest(),   show.legend = NA,   inherit.aes = TRUE )  stat_contour2(   mapping = NULL,   data = NULL,   geom = \"contour2\",   position = \"identity\",   ...,   breaks = MakeBreaks(),   bins = NULL,   binwidth = NULL,   proj = NULL,   proj.latlon = TRUE,   clip = NULL,   kriging = FALSE,   global.breaks = TRUE,   na.rm = FALSE,   na.fill = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"2d contours of a 3d surface — geom_contour2","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). breaks One : numeric vector breaks function takes range data binwidth input returns breaks output bins Number evenly spaced breaks. binwidth Distance breaks. global.breaks Logical indicating whether breaks computed whole data grouping. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. na.fill fill missing values. FALSE letting computation fail interpolation TRUE imputing missing values Impute2D numeric value constant imputation function takes vector returns numeric (e.g. mean) skip number contours skip labelling (e.g. skip = 1 skip 1 contour line labels). margin margin around labels around contour lines clipped avoid overlapping. label.placer label placer function. See label_placer_flattest(). show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. proj projection project contours . can either projection string function apply whole contour dataset. proj.latlon Logical indicating projection step project cartographic projection lon/lat grid way around. clip simple features object used clip. Contours drawn interior polygon. kriging Whether perform ordinary kriging contouring. Use want use contours irregularly spaced data. FALSE, kriging performed. TRUE, kriging performed 40 points. numeric, kriging performed kriging points.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"2d contours of a 3d surface — geom_contour2","text":"geom_contour2 understands following aesthetics (required aesthetics bold): Aesthetics related contour lines: x y z alpha colour group linetype size weight Aesthetics related labels: label label_colour label_alpha label_size family fontface","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed variables","title":"2d contours of a 3d surface — geom_contour2","text":"level height contour","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_contour2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"2d contours of a 3d surface — geom_contour2","text":"","code":"library(ggplot2)  # Breaks can be a function. ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour2(aes(z = value, color = after_stat(level)),                   breaks = AnchorBreaks(130, binwidth = 10))   # Add labels by supplying the label aes. ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour2(aes(z = value, label = after_stat(level)))   ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour2(aes(z = value, label = after_stat(level)),                   skip = 0)   # Use label.placer to control where contours are labelled. ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour2(aes(z = value, label = after_stat(level)),                       label.placer = label_placer_n(n = 2))   # Use the rot_adjuster argument of the placer function to # control the angle. For example, to fix it to some angle: ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour2(aes(z = value, label = after_stat(level)),                   skip = 0,                   label.placer = label_placer_flattest(rot_adjuster = 0))"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":null,"dir":"Reference","previous_headings":"","what":"Filled 2d contours of a 3d surface — geom_contour_fill","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"ggplot2's geom_contour can plot nice contours, work polygon geom. stat makes small manipulation data ensure contours closed also computes new aesthetic int.level, differs level (computed ggplot2::geom_contour) represents value z aesthetic inside contour instead edge. also computes breaks globally instead per panel, faceted plots binwidth.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"","code":"geom_contour_fill(   mapping = NULL,   data = NULL,   stat = \"ContourFill\",   position = \"identity\",   ...,   breaks = MakeBreaks(),   bins = NULL,   binwidth = NULL,   proj = NULL,   proj.latlon = TRUE,   clip = NULL,   kriging = FALSE,   global.breaks = TRUE,   na.fill = FALSE,   show.legend = NA,   inherit.aes = TRUE )  stat_contour_fill(   mapping = NULL,   data = NULL,   geom = \"polygon\",   position = \"identity\",   ...,   breaks = MakeBreaks(),   bins = NULL,   binwidth = NULL,   global.breaks = TRUE,   proj = NULL,   proj.latlon = TRUE,   clip = NULL,   kriging = FALSE,   na.fill = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. breaks numeric vector breaks bins Number evenly spaced breaks. binwidth Distance breaks. proj projection project contours . can either projection string function apply whole contour dataset. proj.latlon Logical indicating projection step project cartographic projection lon/lat grid way around. clip simple features object used clip. Contours drawn interior polygon. kriging Whether perform ordinary kriging contouring. Use want use contours irregularly spaced data. FALSE, kriging performed. TRUE, kriging performed 40 points. numeric, kriging performed kriging points. global.breaks Logical indicating whether breaks computed whole data grouping. na.fill fill missing values. FALSE letting computation fail interpolation TRUE imputing missing values Impute2D numeric value constant imputation function takes vector returns numeric (e.g. mean) show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"geom_contour_fill understands following aesthetics (required aesthetics bold): x y alpha colour group linetype size weight","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed variables","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"level ordered factor represents bin ranges. level_d level, automatically uses scale_fill_discretised() level_low,level_high,level_mid Lower upper bin boundaries band, well mid point boundaries.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_fill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filled 2d contours of a 3d surface — geom_contour_fill","text":"","code":"library(ggplot2) surface <- reshape2::melt(volcano) ggplot(surface, aes(Var1, Var2, z = value)) +   geom_contour_fill() +   geom_contour(color = \"black\", size = 0.1) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead.   ggplot(surface, aes(Var1, Var2, z = value)) +   geom_contour_fill(aes(fill = after_stat(level)))   ggplot(surface, aes(Var1, Var2, z = value)) +   geom_contour_fill(aes(fill = after_stat(level_d)))"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_tanaka.html","id":null,"dir":"Reference","previous_headings":"","what":"Illuminated contours — geom_contour_tanaka","title":"Illuminated contours — geom_contour_tanaka","text":"Illuminated contours (aka Tanaka contours) use varying brightness width create illusion relief. can help distinguishing concave convex areas (local minimums maximums), specially black white plots make photocopy safe plots divergent colour palettes, render aesthetically pleasing representation topography.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_tanaka.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Illuminated contours — geom_contour_tanaka","text":"","code":"geom_contour_tanaka(   mapping = NULL,   data = NULL,   stat = \"Contour2\",   position = \"identity\",   ...,   breaks = NULL,   bins = NULL,   binwidth = NULL,   sun.angle = 60,   light = \"white\",   dark = \"gray20\",   range = c(0.01, 0.5),   smooth = 0,   proj = NULL,   proj.latlon = TRUE,   clip = NULL,   kriging = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_tanaka.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Illuminated contours — geom_contour_tanaka","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. breaks One : numeric vector breaks function takes range data binwidth input returns breaks output bins Number evenly spaced breaks. binwidth Distance breaks. sun.angle angle sun degrees counterclockwise 12 o' clock light, dark valid colour representing light dark shading range numeric vector length 2 minimum maximum size lines smooth numeric indicating degree smoothing illumination size. Larger proj projection project contours . can either projection string function apply whole contour dataset. proj.latlon Logical indicating projection step project cartographic projection lon/lat grid way around. clip simple features object used clip. Contours drawn interior polygon. kriging Whether perform ordinary kriging contouring. Use want use contours irregularly spaced data. FALSE, kriging performed. TRUE, kriging performed 40 points. numeric, kriging performed kriging points. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders().","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_tanaka.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Illuminated contours — geom_contour_tanaka","text":"geom_contour_tanaka understands following aesthetics (required aesthetics bold) x y z linetype","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_contour_tanaka.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Illuminated contours — geom_contour_tanaka","text":"","code":"library(ggplot2) library(data.table) # A fresh look at the boring old volcano dataset ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour_fill(aes(z = value)) +     geom_contour_tanaka(aes(z = value)) +     theme_void()   # If the transition between segments feels too abrupt, # smooth it a bit with smooth ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour_fill(aes(z = value)) +     geom_contour_tanaka(aes(z = value), smooth = 1) +     theme_void()   data(geopotential) geo <- geopotential[date == unique(date)[4]] geo[, gh.z := Anomaly(gh), by = lat] #>         lon   lat   lev       gh       date        gh.z #>       <num> <num> <int>    <num>     <Date>       <num> #>    1:   0.0 -22.5   700 3150.467 1990-04-01  -0.5528954 #>    2:   2.5 -22.5   700 3146.000 1990-04-01  -5.0194482 #>    3:   5.0 -22.5   700 3141.833 1990-04-01  -9.1861962 #>    4:   7.5 -22.5   700 3139.467 1990-04-01 -11.5528954 #>    5:  10.0 -22.5   700 3139.967 1990-04-01 -11.0528954 #>   ---                                                   #> 4028: 347.5 -90.0   700 2696.433 1990-04-01   0.0000000 #> 4029: 350.0 -90.0   700 2696.433 1990-04-01   0.0000000 #> 4030: 352.5 -90.0   700 2696.433 1990-04-01   0.0000000 #> 4031: 355.0 -90.0   700 2696.433 1990-04-01   0.0000000 #> 4032: 357.5 -90.0   700 2696.433 1990-04-01   0.0000000  # In a monochrome contour map, it's impossible to know which areas are # local maximums or minimums. ggplot(geo, aes(lon, lat)) +     geom_contour2(aes(z = gh.z), color = \"black\", xwrap = c(0, 360)) #> Warning: 'xwrap' and 'ywrap' will be deprecated. Use ggperiodic::periodic insead.   # With tanaka contours, they are obvious. ggplot(geo, aes(lon, lat)) +     geom_contour_tanaka(aes(z = gh.z), dark = \"black\",                         xwrap = c(0, 360)) +     scale_fill_divergent() #> Warning: 'xwrap' and 'ywrap' will be deprecated. Use ggperiodic::periodic insead.   # A good divergent color palette has the same luminosity for positive # and negative values.But that means that printed in grayscale (Desaturated), # they are indistinguishable. (g <- ggplot(geo, aes(lon, lat)) +     geom_contour_fill(aes(z = gh.z), xwrap = c(0, 360)) +     scale_fill_gradientn(colours = c(\"#767676\", \"white\", \"#484848\"),                          values = c(0, 0.415, 1))) #> Warning: 'xwrap' and 'ywrap' will be deprecated. Use ggperiodic::periodic insead.   # Tanaka contours can solve this issue. g + geom_contour_tanaka(aes(z = gh.z))"},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":null,"dir":"Reference","previous_headings":"","what":"Relief Shading — geom_relief","title":"Relief Shading — geom_relief","text":"geom_relief() simulates shading caused relief. Can useful plotting topographic data relief shading might give intuitive impression shape terrain contour lines mapping height colour. geom_shadow() projects shadows.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relief Shading — geom_relief","text":"","code":"geom_relief(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   sun.angle = 60,   raster = TRUE,   interpolate = TRUE,   shadow = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_shadow(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   sun.angle = 60,   range = c(0, 1),   skip = 0,   raster = TRUE,   interpolate = TRUE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relief Shading — geom_relief","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. sun.angle angle sun shining, degrees counterclockwise 12 o' clock raster TRUE (default), uses ggplot2::geom_raster, FALSE, uses ggplot2::geom_tile. interpolate TRUE interpolate linearly, FALSE (default) interpolate. shadow TRUE, adds also layer geom_shadow() na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). range transparency range shadows skip data points skip casting shadows","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relief Shading — geom_relief","text":"light dark must valid colours determining light dark shading (defaults \"white\" \"gray20\", respectively).","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Relief Shading — geom_relief","text":"geom_relief() geom_shadow() understands following aesthetics (required aesthetics bold) x y z light dark sun.angle","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_relief.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relief Shading — geom_relief","text":"","code":"if (FALSE) { # \\dontrun{ library(ggplot2) ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +       geom_relief(aes(z = value)) } # }"},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":null,"dir":"Reference","previous_headings":"","what":"Streamlines — geom_streamline","title":"Streamlines — geom_streamline","text":"Streamlines paths always tangential vector field. case steady field, identical path massless particle moves \"flow\".","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Streamlines — geom_streamline","text":"","code":"geom_streamline(   mapping = NULL,   data = NULL,   stat = \"streamline\",   position = \"identity\",   ...,   L = 5,   min.L = 0,   res = 1,   S = NULL,   dt = NULL,   xwrap = NULL,   ywrap = NULL,   skip = 1,   skip.x = skip,   skip.y = skip,   n = NULL,   nx = n,   ny = n,   jitter = 1,   jitter.x = jitter,   jitter.y = jitter,   arrow.angle = 6,   arrow.length = 0.5,   arrow.ends = \"last\",   arrow.type = \"closed\",   arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, \"lines\"), ends = arrow.ends,     type = arrow.type),   lineend = \"butt\",   na.rm = TRUE,   show.legend = NA,   inherit.aes = TRUE )  stat_streamline(   mapping = NULL,   data = NULL,   geom = \"streamline\",   position = \"identity\",   ...,   L = 5,   min.L = 0,   res = 1,   S = NULL,   dt = NULL,   xwrap = NULL,   ywrap = NULL,   skip = 1,   skip.x = skip,   skip.y = skip,   n = NULL,   nx = n,   ny = n,   jitter = 1,   jitter.x = jitter,   jitter.y = jitter,   arrow.angle = 6,   arrow.length = 0.5,   arrow.ends = \"last\",   arrow.type = \"closed\",   arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, \"lines\"), ends = arrow.ends,     type = arrow.type),   lineend = \"butt\",   na.rm = TRUE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Streamlines — geom_streamline","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. L, typical length streamline x y units min.L minimum length segments show res, resolution parameter (higher numbers increases resolution) S optional numeric number timesteps integration dt optional numeric size \"timestep\" integration xwrap, ywrap vector length two used wrap circular dimension. skip, skip.x, skip.y numeric specifying number gridpoints draw x y direction n, nx, ny optional numeric indicating number points draw x y direction (replaces skip NULL) jitter, jitter.x, jitter.y amount jitter starting points arrow.length, arrow.angle, arrow.ends, arrow.type parameters passed grid::arrow arrow specification arrow heads, created grid::arrow(). lineend Line end style (round, butt, square). na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Streamlines — geom_streamline","text":"Streamlines computed simple integration forward Euler method. default, stat_streamline() computes dt S L, res, resolution grid mean magnitude field. S defined number steps necessary make streamline length L uniform mean field dt chosen step larger resolution data (divided res parameter). aware rule thumb might fail field skewed distribution magnitudes. Alternatively, L /res ignored S /dt specified explicitly. makes possible fine-tune result also divorces integration parameters properties data makes possible compare streamlines different fields. starting grid semi regular grid defined, either resolution field skip.x skip.y parameters o nx ny parameters, jittered amount proportional resolution data jitter.x jitter.y parameters. might important units vector field compatible units x y dimensions. example, passing dx dy m/s longitude-latitude grid might misleading results (see spherical). Missing values permitted field must defined regular grid, now.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Streamlines — geom_streamline","text":"stat_streamline understands following aesthetics (required aesthetics bold) x y dx dy alpha colour linetype size","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed variables","title":"Streamlines — geom_streamline","text":"step step simulation dx dx location streamline dy dy location streamline","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_streamline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Streamlines — geom_streamline","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) library(ggplot2) data(geopotential)  geopotential <- copy(geopotential)[date == date[1]] geopotential[, gh.z := Anomaly(gh), by = .(lat)] geopotential[, c(\"u\", \"v\") := GeostrophicWind(gh.z, lon, lat)]  (g <- ggplot(geopotential, aes(lon, lat)) +     geom_contour2(aes(z = gh.z), xwrap = c(0, 360)) +     geom_streamline(aes(dx = dlon(u, lat), dy = dlat(v)), L = 60,                     xwrap = c(0, 360)))  # The circular parameter is particularly important for polar coordinates g + coord_polar()  # If u and v are not converted into degrees/second, the resulting # streamlines have problems, specially near the pole. ggplot(geopotential, aes(lon, lat)) +     geom_contour(aes(z = gh.z)) +     geom_streamline(aes(dx = u, dy = v), L = 50)  # The step variable can be mapped to size or alpha to # get cute \"drops\". It's important to note that after_stat(dx) (the calculated variable) # is NOT the same as dx (from the data). ggplot(geopotential, aes(lon, lat)) +     geom_streamline(aes(dx = dlon(u, lat), dy = dlat(v), alpha = after_stat(step),                         color = sqrt(after_stat(dx^2) + after_stat(dy^2)),                         size = after_stat(step)),                         L = 40, xwrap = c(0, 360), res = 2, arrow = NULL,                         lineend = \"round\") +     scale_size(range = c(0, 0.6))  # Using topographic information to simulate \"rivers\" from slope topo <- GetTopography(295, -55+360, -30, -42, res = 1/20)  # needs internet! topo[, c(\"dx\", \"dy\") := Derivate(h ~ lon + lat)] topo[h <= 0, c(\"dx\", \"dy\") := 0]  # See how in this example the integration step is too coarse in the # western montanous region where the slope is much higher than in the # flatlands of La Pampa at in the east. ggplot(topo, aes(lon, lat)) +     geom_relief(aes(z = h), interpolate = TRUE, data = topo[h >= 0]) +     geom_contour(aes(z = h), breaks = 0, color = \"black\") +     geom_streamline(aes(dx = -dx, dy = -dy), L = 10, skip = 3, arrow = NULL,                     color = \"#4658BD\") +     coord_quickmap()  } # }"},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":null,"dir":"Reference","previous_headings":"","what":"Label contours — geom_label_contour","title":"Label contours — geom_label_contour","text":"Draws labels contours built ggplot2::stat_contour.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label contours — geom_label_contour","text":"","code":"geom_label_contour(   mapping = NULL,   data = NULL,   stat = \"text_contour\",   position = \"identity\",   ...,   min.size = 5,   skip = 1,   label.placer = label_placer_flattest(),   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   label.padding = grid::unit(0.25, \"lines\"),   label.r = grid::unit(0.15, \"lines\"),   label.size = 0.25,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_text_contour(   mapping = NULL,   data = NULL,   stat = \"text_contour\",   position = \"identity\",   ...,   min.size = 5,   skip = 1,   rotate = TRUE,   label.placer = label_placer_flattest(),   parse = FALSE,   nudge_x = 0,   nudge_y = 0,   stroke = 0,   check_overlap = FALSE,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label contours — geom_label_contour","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. min.size minimum number points contour labelled. skip number contours skip label.placer label placer function. See label_placer_flattest(). parse TRUE, labels parsed expressions displayed described ?plotmath. nudge_x, nudge_y Horizontal vertical adjustment nudge labels . Useful offsetting text points, particularly discrete scales. jointly specified position. label.padding Amount padding around label. Defaults 0.25 lines. label.r Radius rounded corners. Defaults 0.15 lines. label.size Replaced linewidth aesthetic. Size label border, mm. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). rotate logical indicating whether rotate text following contour. stroke numerical indicating width stroke relative size text. Ignored less zero. check_overlap TRUE, text overlaps previous text layer plotted. check_overlap happens draw time order data. Therefore data arranged label column calling geom_text(). Note argument supported geom_label().","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label contours — geom_label_contour","text":"best used previous call ggplot2::stat_contour parameters (e.g. binwidth, breaks, bins). Note geom_text_contour() can angle follow contour, case geom_label_contour().","code":""},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Label contours — geom_label_contour","text":"geom_text_contour understands following aesthetics (required aesthetics bold): x y label alpha angle colour stroke.color family fontface group hjust lineheight size vjust","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/geom_text_contour.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label contours — geom_label_contour","text":"","code":"library(ggplot2) v <- reshape2::melt(volcano) g <- ggplot(v, aes(Var1, Var2)) +        geom_contour(aes(z = value)) g + geom_text_contour(aes(z = value))   g + geom_text_contour(aes(z = value), stroke = 0.2)   g + geom_text_contour(aes(z = value), stroke = 0.2, stroke.colour = \"red\")   g + geom_text_contour(aes(z = value, stroke.colour = after_stat(level)), stroke = 0.2) +     scale_colour_gradient(aesthetics = \"stroke.colour\", guide = \"none\")   g + geom_text_contour(aes(z = value), rotate = FALSE)   g + geom_text_contour(aes(z = value),                       label.placer = label_placer_random())   g + geom_text_contour(aes(z = value),                       label.placer = label_placer_n(3))   g + geom_text_contour(aes(z = value),                       label.placer = label_placer_flattest())   g + geom_text_contour(aes(z = value),                       label.placer = label_placer_flattest(ref_angle = 90))"},{"path":"https://eliocamp.github.io/metR/reference/geopotential.html","id":null,"dir":"Reference","previous_headings":"","what":"Geopotential height — geopotential","title":"Geopotential height — geopotential","text":"Monthly geopotential field 700hPa south 20°S January 1990 December 2000.","code":""},{"path":"https://eliocamp.github.io/metR/reference/geopotential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geopotential height — geopotential","text":"","code":"geopotential"},{"path":"https://eliocamp.github.io/metR/reference/geopotential.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Geopotential height — geopotential","text":"data.table 53224 rows 5 variables. lon longitude degrees lat latitude degrees lev level hPa gh geopotential height meters date date","code":""},{"path":"https://eliocamp.github.io/metR/reference/geopotential.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Geopotential height — geopotential","text":"https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html","code":""},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":null,"dir":"Reference","previous_headings":"","what":"Discretized continuous colour guide — guide_colourstrip","title":"Discretized continuous colour guide — guide_colourstrip","text":"version ggplot2::guide_colourbar displays discretized values , default, puts labels values.","code":""},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discretized continuous colour guide — guide_colourstrip","text":"","code":"guide_colourstrip(   title = ggplot2::waiver(),   title.position = NULL,   title.theme = NULL,   title.hjust = NULL,   title.vjust = NULL,   label = TRUE,   label.position = NULL,   label.theme = NULL,   label.hjust = NULL,   label.vjust = NULL,   barwidth = NULL,   barheight = NULL,   ticks = FALSE,   draw.ulim = TRUE,   draw.llim = TRUE,   inside = FALSE,   direction = NULL,   default.unit = \"line\",   reverse = FALSE,   order = 0,   available_aes = c(\"colour\", \"color\", \"fill\"),   ... )  guide_colorstrip(   title = ggplot2::waiver(),   title.position = NULL,   title.theme = NULL,   title.hjust = NULL,   title.vjust = NULL,   label = TRUE,   label.position = NULL,   label.theme = NULL,   label.hjust = NULL,   label.vjust = NULL,   barwidth = NULL,   barheight = NULL,   ticks = FALSE,   draw.ulim = TRUE,   draw.llim = TRUE,   inside = FALSE,   direction = NULL,   default.unit = \"line\",   reverse = FALSE,   order = 0,   available_aes = c(\"colour\", \"color\", \"fill\"),   ... )"},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discretized continuous colour guide — guide_colourstrip","text":"title character string expression indicating title guide. NULL, title shown. default (waiver()), name scale object name specified labs() used title. draw.ulim logical specifying upper limit tick marks visible. draw.llim logical specifying lower limit tick marks visible. inside logical indicating position labels (see examples). direction character string indicating direction guide. One \"horizontal\" \"vertical.\" reverse logical. TRUE colourbar reversed. default, highest value top lowest value bottom order positive integer less 99 specifies order guide among multiple guides. controls order multiple guides displayed, contents guide . 0 (default), order determined secret algorithm. available_aes vector character strings listing aesthetics colourbar can drawn. ... ignored. theme theme object style guide individually differently plot's theme settings. theme argument guide partially overrides, combined , plot's theme. Arguments apply single legend respected, legend-prefix. Arguments apply combined legends (legend box) ignored, including legend.position, legend.justification.*, legend.location legend.box.*.","code":""},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discretized continuous colour guide — guide_colourstrip","text":"guide object.","code":""},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discretized continuous colour guide — guide_colourstrip","text":"default behaviour works fell geom_contour_fill colours represent value contour surfaces. `inside = TRUE“ works better geom_tile colour represents value data similar ggplot2::guide_legend.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/guide_colourstrip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discretized continuous colour guide — guide_colourstrip","text":"","code":"# In this example the lowest colour represents an area of the data with values # between 80 and 100. library(ggplot2) binwidth <- 20 data(volcano) ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +     geom_contour_fill(binwidth = binwidth) +     scale_fill_continuous(guide = guide_colourstrip(),                          breaks = MakeBreaks(binwidth)) #> Warning: The S3 guide system was deprecated in ggplot2 3.5.0. #> ℹ It has been replaced by a ggproto system that can be extended.   # Difference between guide_legend() and guide_colorbar2(inside = T) df <- reshape2::melt(outer(1:4, 1:4), varnames = c(\"X1\", \"X2\")) g <- ggplot(df, aes(X1, X2)) +         geom_tile(aes(fill = value)) +         theme(legend.position = \"bottom\")  # Tick labels are to the side g + scale_fill_continuous(guide = guide_legend())  # Tick labels are at the bottom g + scale_fill_continuous(guide = guide_colourstrip(inside = TRUE))"},{"path":"https://eliocamp.github.io/metR/reference/is.cross.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross pattern — is.cross","title":"Cross pattern — is.cross","text":"Reduces density regular grid using cross pattern.","code":""},{"path":"https://eliocamp.github.io/metR/reference/is.cross.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross pattern — is.cross","text":"","code":"is.cross(x, y, skip = 0)  cross(x, y)"},{"path":"https://eliocamp.github.io/metR/reference/is.cross.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross pattern — is.cross","text":"x, y x y points define regular grid. skip many points skip. Greater value reduces final point density.","code":""},{"path":"https://eliocamp.github.io/metR/reference/is.cross.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross pattern — is.cross","text":".cross returns logical vector indicating whether point belongs reduced grid . cross returns list x y components reduced density grid.","code":""},{"path":"https://eliocamp.github.io/metR/reference/is.cross.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross pattern — is.cross","text":"","code":"# Basic usage grid <- expand.grid(x = 1:10, y = 1:10) cross <- is.cross(grid$x, grid$y, skip = 2)  with(grid, plot(x, y)) with(grid, points(x[cross], y[cross], col = \"red\"))   # Its intended use is to highlight areas with geom_subset() # with reduced densnity. This \"hatches\" areas with temperature # over 270K library(ggplot2) ggplot(temperature[lev == 500], aes(lon, lat)) +   geom_raster(aes(fill = air)) +   stat_subset(aes(subset = air > 270 & is.cross(lon, lat)),               geom = \"point\", size = 0.1)"},{"path":"https://eliocamp.github.io/metR/reference/label_placers.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions to place contour labels — label_placers","title":"Functions to place contour labels — label_placers","text":"functions compute position contour labels.","code":""},{"path":"https://eliocamp.github.io/metR/reference/label_placers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions to place contour labels — label_placers","text":"","code":"label_placer_fraction(   frac = 0.5,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placement_fraction(   frac = 0.5,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placer_n(n = 2, rot_adjuster = isoband::angle_halfcircle_bottom())  label_placement_n(n = 2, rot_adjuster = isoband::angle_halfcircle_bottom())  label_placer_random(   seed = 42,   n = 1,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placement_random(   seed = 42,   n = 1,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placer_all(rot_adjuster = isoband::angle_halfcircle_bottom())  label_placement_all(rot_adjuster = isoband::angle_halfcircle_bottom())  label_placer_flattest(   ref_angle = 0,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placement_flattest(   ref_angle = 0,   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placer_minmax(   direction = c(\"vertical\", \"horizontal\"),   rot_adjuster = isoband::angle_halfcircle_bottom() )  label_placement_minmax(   direction = c(\"vertical\", \"horizontal\"),   rot_adjuster = isoband::angle_halfcircle_bottom() )"},{"path":"https://eliocamp.github.io/metR/reference/label_placers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions to place contour labels — label_placers","text":"frac numeric vector values 0 1 representing contour put labels (.e. frac = 0.5 puts labels midpoint). rot_adjuster function standardizes rotation angles labels. See e.g. isoband::angle_halfcircle_bottom. n Number labels put. seed Seed use randomly choosing put labels. ref_angle Angle (degrees counter-clockwise East) try approximate labels. direction Direction compute maximum minimum.","code":""},{"path":"https://eliocamp.github.io/metR/reference/label_scales.html","id":null,"dir":"Reference","previous_headings":"","what":"Scales for contour label aesthetics — scale_label_colour_continuous","title":"Scales for contour label aesthetics — scale_label_colour_continuous","text":"Scales contour label aesthetics","code":""},{"path":"https://eliocamp.github.io/metR/reference/label_scales.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scales for contour label aesthetics — scale_label_colour_continuous","text":"","code":"scale_label_colour_continuous(   ...,   aesthetics = c(\"label_colour\"),   guide = ggplot2::guide_colorbar(available_aes = \"label_colour\") )  scale_label_alpha_continuous(   ...,   range = c(0.1, 1),   aesthetics = c(\"label_alpha\") )  scale_label_size_continuous(   breaks = waiver(),   labels = waiver(),   limits = NULL,   range = c(1, 6),   transform = \"identity\",   guide = \"legend\" )"},{"path":"https://eliocamp.github.io/metR/reference/label_scales.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scales for contour label aesthetics — scale_label_colour_continuous","text":"... Arguments passed continuous_scale minor_breaks One : NULL minor breaks waiver() default breaks (none discrete, one minor break major break continuous) numeric vector positions function given limits returns vector minor breaks. Also accepts rlang lambda function notation. function two arguments, given limits major break positions. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. na.value Missing values replaced value. call call used construct scale reporting messages. super super class use constructed scale aesthetics Character string vector character strings listing name(s) aesthetic(s) scale works . can useful, example, apply colour settings colour fill aesthetics time, via aesthetics = c(\"colour\", \"fill\"). guide Type legend. Use \"colourbar\" continuous colour bar, \"legend\" discrete colour legend. range Output range alpha values. Must lie 0 1. breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. labels One options . Please note labels vector, highly recommended also set breaks argument vector protect unintended mismatches. NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). transform continuous scales, name transformation object object . Built-transformations include \"asn\", \"atanh\", \"boxcox\", \"date\", \"exp\", \"hms\", \"identity\", \"log\", \"log10\", \"log1p\", \"log2\", \"logit\", \"modulus\", \"probability\", \"probit\", \"pseudo_log\", \"reciprocal\", \"reverse\", \"sqrt\" \"time\". transformation object bundles together transform, inverse, methods generating breaks labels. Transformation objects defined scales package, called transform_<name>. transformations require arguments, can call scales package, e.g. scales::transform_boxcox(p = 2). can create transformation scales::new_transform().","code":""},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":null,"dir":"Reference","previous_headings":"","what":"Extended logical operators — logic","title":"Extended logical operators — logic","text":"Extended binary operators easy subsetting.","code":""},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extended logical operators — logic","text":"","code":"x %~% target  Similar(x, target, tol = Inf)"},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extended logical operators — logic","text":"x, target numeric vectors tol tolerance similarity","code":""},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extended logical operators — logic","text":"logical vector length x.","code":""},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extended logical operators — logic","text":"%~% can thought \"similar\" operator. fuzzy version %% returns TRUE element x (first) closest element target. Similar functional version %~% also tol parameter indicates maximum allowed tolerance.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/logic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extended logical operators — logic","text":"","code":"set.seed(198) x <- rnorm(100) x[x %~% c(0.3, 0.5, 1)] #> [1] 0.4979594 0.3024046 0.9361350  # Practical use case: vertical cross-section at # approximately 36W between 50S and 50N. cross.lon <- -34 + 360 library(ggplot2) library(data.table) ggplot(temperature[lon %~% cross.lon & lat %between% c(-50, 50)],        aes(lat, lev)) +     geom_contour(aes(z = air))"},{"path":"https://eliocamp.github.io/metR/reference/map_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Label longitude and latitude — map_labels","title":"Label longitude and latitude — map_labels","text":"Provide easy functions adding suffixes longitude latitude labelling maps.","code":""},{"path":"https://eliocamp.github.io/metR/reference/map_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label longitude and latitude — map_labels","text":"","code":"LonLabel(lon, east = \"°E\", west = \"°W\", zero = \"°\")  LatLabel(lat, north = \"°N\", south = \"°S\", zero = \"°\")"},{"path":"https://eliocamp.github.io/metR/reference/map_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label longitude and latitude — map_labels","text":"lon longitude degrees east, west, north, south, zero text append quadrant lat latitude degrees","code":""},{"path":"https://eliocamp.github.io/metR/reference/map_labels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label longitude and latitude — map_labels","text":"default values Spanish.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/map_labels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label longitude and latitude — map_labels","text":"","code":"LonLabel(0:360) #>   [1] \"0°\"    \"1°E\"   \"2°E\"   \"3°E\"   \"4°E\"   \"5°E\"   \"6°E\"   \"7°E\"   \"8°E\"   #>  [10] \"9°E\"   \"10°E\"  \"11°E\"  \"12°E\"  \"13°E\"  \"14°E\"  \"15°E\"  \"16°E\"  \"17°E\"  #>  [19] \"18°E\"  \"19°E\"  \"20°E\"  \"21°E\"  \"22°E\"  \"23°E\"  \"24°E\"  \"25°E\"  \"26°E\"  #>  [28] \"27°E\"  \"28°E\"  \"29°E\"  \"30°E\"  \"31°E\"  \"32°E\"  \"33°E\"  \"34°E\"  \"35°E\"  #>  [37] \"36°E\"  \"37°E\"  \"38°E\"  \"39°E\"  \"40°E\"  \"41°E\"  \"42°E\"  \"43°E\"  \"44°E\"  #>  [46] \"45°E\"  \"46°E\"  \"47°E\"  \"48°E\"  \"49°E\"  \"50°E\"  \"51°E\"  \"52°E\"  \"53°E\"  #>  [55] \"54°E\"  \"55°E\"  \"56°E\"  \"57°E\"  \"58°E\"  \"59°E\"  \"60°E\"  \"61°E\"  \"62°E\"  #>  [64] \"63°E\"  \"64°E\"  \"65°E\"  \"66°E\"  \"67°E\"  \"68°E\"  \"69°E\"  \"70°E\"  \"71°E\"  #>  [73] \"72°E\"  \"73°E\"  \"74°E\"  \"75°E\"  \"76°E\"  \"77°E\"  \"78°E\"  \"79°E\"  \"80°E\"  #>  [82] \"81°E\"  \"82°E\"  \"83°E\"  \"84°E\"  \"85°E\"  \"86°E\"  \"87°E\"  \"88°E\"  \"89°E\"  #>  [91] \"90°E\"  \"91°E\"  \"92°E\"  \"93°E\"  \"94°E\"  \"95°E\"  \"96°E\"  \"97°E\"  \"98°E\"  #> [100] \"99°E\"  \"100°E\" \"101°E\" \"102°E\" \"103°E\" \"104°E\" \"105°E\" \"106°E\" \"107°E\" #> [109] \"108°E\" \"109°E\" \"110°E\" \"111°E\" \"112°E\" \"113°E\" \"114°E\" \"115°E\" \"116°E\" #> [118] \"117°E\" \"118°E\" \"119°E\" \"120°E\" \"121°E\" \"122°E\" \"123°E\" \"124°E\" \"125°E\" #> [127] \"126°E\" \"127°E\" \"128°E\" \"129°E\" \"130°E\" \"131°E\" \"132°E\" \"133°E\" \"134°E\" #> [136] \"135°E\" \"136°E\" \"137°E\" \"138°E\" \"139°E\" \"140°E\" \"141°E\" \"142°E\" \"143°E\" #> [145] \"144°E\" \"145°E\" \"146°E\" \"147°E\" \"148°E\" \"149°E\" \"150°E\" \"151°E\" \"152°E\" #> [154] \"153°E\" \"154°E\" \"155°E\" \"156°E\" \"157°E\" \"158°E\" \"159°E\" \"160°E\" \"161°E\" #> [163] \"162°E\" \"163°E\" \"164°E\" \"165°E\" \"166°E\" \"167°E\" \"168°E\" \"169°E\" \"170°E\" #> [172] \"171°E\" \"172°E\" \"173°E\" \"174°E\" \"175°E\" \"176°E\" \"177°E\" \"178°E\" \"179°E\" #> [181] \"180°\"  \"179°W\" \"178°W\" \"177°W\" \"176°W\" \"175°W\" \"174°W\" \"173°W\" \"172°W\" #> [190] \"171°W\" \"170°W\" \"169°W\" \"168°W\" \"167°W\" \"166°W\" \"165°W\" \"164°W\" \"163°W\" #> [199] \"162°W\" \"161°W\" \"160°W\" \"159°W\" \"158°W\" \"157°W\" \"156°W\" \"155°W\" \"154°W\" #> [208] \"153°W\" \"152°W\" \"151°W\" \"150°W\" \"149°W\" \"148°W\" \"147°W\" \"146°W\" \"145°W\" #> [217] \"144°W\" \"143°W\" \"142°W\" \"141°W\" \"140°W\" \"139°W\" \"138°W\" \"137°W\" \"136°W\" #> [226] \"135°W\" \"134°W\" \"133°W\" \"132°W\" \"131°W\" \"130°W\" \"129°W\" \"128°W\" \"127°W\" #> [235] \"126°W\" \"125°W\" \"124°W\" \"123°W\" \"122°W\" \"121°W\" \"120°W\" \"119°W\" \"118°W\" #> [244] \"117°W\" \"116°W\" \"115°W\" \"114°W\" \"113°W\" \"112°W\" \"111°W\" \"110°W\" \"109°W\" #> [253] \"108°W\" \"107°W\" \"106°W\" \"105°W\" \"104°W\" \"103°W\" \"102°W\" \"101°W\" \"100°W\" #> [262] \"99°W\"  \"98°W\"  \"97°W\"  \"96°W\"  \"95°W\"  \"94°W\"  \"93°W\"  \"92°W\"  \"91°W\"  #> [271] \"90°W\"  \"89°W\"  \"88°W\"  \"87°W\"  \"86°W\"  \"85°W\"  \"84°W\"  \"83°W\"  \"82°W\"  #> [280] \"81°W\"  \"80°W\"  \"79°W\"  \"78°W\"  \"77°W\"  \"76°W\"  \"75°W\"  \"74°W\"  \"73°W\"  #> [289] \"72°W\"  \"71°W\"  \"70°W\"  \"69°W\"  \"68°W\"  \"67°W\"  \"66°W\"  \"65°W\"  \"64°W\"  #> [298] \"63°W\"  \"62°W\"  \"61°W\"  \"60°W\"  \"59°W\"  \"58°W\"  \"57°W\"  \"56°W\"  \"55°W\"  #> [307] \"54°W\"  \"53°W\"  \"52°W\"  \"51°W\"  \"50°W\"  \"49°W\"  \"48°W\"  \"47°W\"  \"46°W\"  #> [316] \"45°W\"  \"44°W\"  \"43°W\"  \"42°W\"  \"41°W\"  \"40°W\"  \"39°W\"  \"38°W\"  \"37°W\"  #> [325] \"36°W\"  \"35°W\"  \"34°W\"  \"33°W\"  \"32°W\"  \"31°W\"  \"30°W\"  \"29°W\"  \"28°W\"  #> [334] \"27°W\"  \"26°W\"  \"25°W\"  \"24°W\"  \"23°W\"  \"22°W\"  \"21°W\"  \"20°W\"  \"19°W\"  #> [343] \"18°W\"  \"17°W\"  \"16°W\"  \"15°W\"  \"14°W\"  \"13°W\"  \"12°W\"  \"11°W\"  \"10°W\"  #> [352] \"9°W\"   \"8°W\"   \"7°W\"   \"6°W\"   \"5°W\"   \"4°W\"   \"3°W\"   \"2°W\"   \"1°W\"   #> [361] \"0°\""},{"path":"https://eliocamp.github.io/metR/reference/metR.html","id":null,"dir":"Reference","previous_headings":"","what":"metR: Tools for Easier Analysis of Meteorological Fields — metR","title":"metR: Tools for Easier Analysis of Meteorological Fields — metR","text":"Many useful functions extensions dealing meteorological data tidy data framework. Extends 'ggplot2' better plotting scalar vector fields provides commonly used analysis methods atmospheric sciences.","code":""},{"path":"https://eliocamp.github.io/metR/reference/metR.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"metR: Tools for Easier Analysis of Meteorological Fields — metR","text":"Conceptually divided visualization tools data tools. former geoms, stats scales help plotting using 'ggplot2', stat_contour_fill scale_y_level, later functions common data processing tools atmospheric sciences, Derivate EOF; implemented work 'data.table' paradigm, also work regular data frames. get started, check vignettes: Visualization Tools: vignette(\"Visualization-tools\", package = \"metR\") Working Data: vignette(\"Working--data\", package = \"metR\")","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/metR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"metR: Tools for Easier Analysis of Meteorological Fields — metR","text":"Maintainer: Elio Campitelli eliocampitelli@gmail.com (ORCID)","code":""},{"path":"https://eliocamp.github.io/metR/reference/reverselog_trans.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse log transform — reverselog_trans","title":"Reverse log transform — reverselog_trans","text":"Reverse log transformation. Useful plotting one axis pressure levels.","code":""},{"path":"https://eliocamp.github.io/metR/reference/reverselog_trans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse log transform — reverselog_trans","text":"","code":"reverselog_trans(base = 10)"},{"path":"https://eliocamp.github.io/metR/reference/reverselog_trans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse log transform — reverselog_trans","text":"base Base logarithm","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/reverselog_trans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse log transform — reverselog_trans","text":"","code":"# Adiabatic temperature profile gamma <- 0.286 t <- data.frame(p = c(1000, 950, 850, 700, 500, 300, 200, 100)) t$t <- 300*(t$p/1000)^gamma  library(ggplot2) ggplot(t, aes(p, t)) +    geom_line() +    coord_flip() +    scale_x_continuous(trans = \"reverselog\")"},{"path":"https://eliocamp.github.io/metR/reference/scale_divergent.html","id":null,"dir":"Reference","previous_headings":"","what":"Divergent colour scales — scale_divergent","title":"Divergent colour scales — scale_divergent","text":"Wrapper around ggplot's scale_colour_gradient2 inverted defaults high low.","code":""},{"path":"https://eliocamp.github.io/metR/reference/scale_divergent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divergent colour scales — scale_divergent","text":"","code":"scale_colour_divergent(   ...,   low = scales::muted(\"blue\"),   mid = \"white\",   high = scales::muted(\"red\"),   midpoint = 0,   space = \"Lab\",   na.value = \"grey50\",   guide = \"colourbar\" )  scale_color_divergent(   ...,   low = scales::muted(\"blue\"),   mid = \"white\",   high = scales::muted(\"red\"),   midpoint = 0,   space = \"Lab\",   na.value = \"grey50\",   guide = \"colourbar\" )  scale_fill_divergent(   ...,   low = scales::muted(\"blue\"),   mid = \"white\",   high = scales::muted(\"red\"),   midpoint = 0,   space = \"Lab\",   na.value = \"grey50\",   guide = \"colourbar\" )"},{"path":"https://eliocamp.github.io/metR/reference/scale_divergent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divergent colour scales — scale_divergent","text":"... Arguments passed continuous_scale scale_name name scale used error messages associated scale. breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. minor_breaks One : NULL minor breaks waiver() default breaks (none discrete, one minor break major break continuous) numeric vector positions function given limits returns vector minor breaks. Also accepts rlang lambda function notation. function two arguments, given limits major break positions. n.breaks integer guiding number major breaks. algorithm may choose slightly different number ensure nice break labels. effect breaks = waiver(). Use NULL use default number breaks given transformation. labels One options . Please note labels vector, highly recommended also set breaks argument vector protect unintended mismatches. NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). rescaler function used scale input values range [0, 1]. always scales::rescale(), except diverging n colour gradients (.e., scale_colour_gradient2(), scale_colour_gradientn()). rescaler ignored position scales, always use scales::rescale(). Also accepts rlang lambda function notation. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. trans Deprecated favour transform. call call used construct scale reporting messages. super super class use constructed scale low, high Colours low high ends gradient. mid colour mid point midpoint midpoint (data value) diverging scale. Defaults 0. space colour space calculate gradient. Must \"Lab\" - values deprecated. na.value Colour use missing values guide Type legend. Use \"colourbar\" continuous colour bar, \"legend\" discrete colour legend.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/scale_divergent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divergent colour scales — scale_divergent","text":"","code":"library(ggplot2) ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +   geom_contour(aes(color = after_stat(level))) +   scale_colour_divergent(midpoint = 130)"},{"path":"https://eliocamp.github.io/metR/reference/scale_longitude.html","id":null,"dir":"Reference","previous_headings":"","what":"Helpful scales for maps — scale_longitude","title":"Helpful scales for maps — scale_longitude","text":"functions simple wrappers around scale_x_continuous scale_y_continuous helpful defaults plotting longitude, latitude pressure levels.","code":""},{"path":"https://eliocamp.github.io/metR/reference/scale_longitude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helpful scales for maps — scale_longitude","text":"","code":"scale_x_longitude(   name = \"\",   ticks = 30,   breaks = seq(-180, 360, by = ticks),   expand = c(0, 0),   labels = LonLabel,   ... )  scale_y_longitude(   name = \"\",   ticks = 60,   breaks = seq(-180, 360, by = ticks),   expand = c(0, 0),   labels = LonLabel,   ... )  scale_x_latitude(   name = \"\",   ticks = 30,   breaks = seq(-90, 90, by = ticks),   expand = c(0, 0),   labels = LatLabel,   ... )  scale_y_latitude(   name = \"\",   ticks = 30,   breaks = seq(-90, 90, by = ticks),   expand = c(0, 0),   labels = LatLabel,   ... )  scale_x_level(name = \"\", expand = c(0, 0), trans = \"reverselog\", ...)  scale_y_level(name = \"\", expand = c(0, 0), trans = \"reverselog\", ...)"},{"path":"https://eliocamp.github.io/metR/reference/scale_longitude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helpful scales for maps — scale_longitude","text":"name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. ticks spacing breaks breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function ggplot2::expansion() generate values expand argument. labels One options . Please note labels vector, highly recommended also set breaks argument vector protect unintended mismatches. NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. ... arguments passed scale_(x|y)_continuous() trans Deprecated favour transform.","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/scale_longitude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helpful scales for maps — scale_longitude","text":"","code":"data(geopotential) library(ggplot2) ggplot(geopotential[date == date[1]], aes(lon, lat, z = gh)) +     geom_contour() +     scale_x_longitude() +     scale_y_latitude()   data(temperature) ggplot(temperature[lon == lon[1] & lat == lat[1]], aes(air, lev)) +     geom_path() +     scale_y_level()"},{"path":"https://eliocamp.github.io/metR/reference/scale_mag.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale for vector magnitudes — scale_mag","title":"Scale for vector magnitudes — scale_mag","text":"Allows control size arrows geom_arrow. Highly experimental.","code":""},{"path":"https://eliocamp.github.io/metR/reference/scale_mag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale for vector magnitudes — scale_mag","text":"","code":"scale_mag(   name = ggplot2::waiver(),   n.breaks = 1,   breaks = ggplot2::waiver(),   oob = no_censor,   ... )  scale_mag_continuous(   name = ggplot2::waiver(),   n.breaks = 1,   breaks = ggplot2::waiver(),   oob = no_censor,   ... )"},{"path":"https://eliocamp.github.io/metR/reference/scale_mag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale for vector magnitudes — scale_mag","text":"name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. n.breaks integer guiding number major breaks. algorithm may choose slightly different number ensure nice break labels. effect breaks = waiver(). Use NULL use default number breaks given transformation. breaks One : NULL breaks waiver() default breaks computed transformation object numeric vector positions function takes limits input returns breaks output (e.g., function returned scales::extended_breaks()). Note position scales, limits provided scale expansion. Also accepts rlang lambda function notation. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. ... arguments passed scale_(x|y)_continuous()","code":""},{"path":"https://eliocamp.github.io/metR/reference/scale_mag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale for vector magnitudes — scale_mag","text":"","code":"library(ggplot2) g <- ggplot(seals, aes(long, lat)) +     geom_vector(aes(dx = delta_long, dy = delta_lat), skip = 2)  g + scale_mag(\"Seals velocity\")   g + scale_mag(\"Seals velocity\", limits = c(0, 1))"},{"path":"https://eliocamp.github.io/metR/reference/scale_stroke.colour_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale for stroke.colour — scale_stroke.colour_continuous","title":"Scale for stroke.colour — scale_stroke.colour_continuous","text":"Scale stroke.colour","code":""},{"path":"https://eliocamp.github.io/metR/reference/scale_stroke.colour_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale for stroke.colour — scale_stroke.colour_continuous","text":"... parameters sent ggplot2::scale_color_continuous","code":""},{"path":"https://eliocamp.github.io/metR/reference/season.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign seasons to months — season","title":"Assign seasons to months — season","text":"Assign seasons months","code":""},{"path":"https://eliocamp.github.io/metR/reference/season.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign seasons to months — season","text":"","code":"season(x, lang = c(\"en\", \"es\"))  seasonally(x)  is.full_season(x)"},{"path":"https://eliocamp.github.io/metR/reference/season.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign seasons to months — season","text":"x vector dates (alternative numeric vector months, season()) lang Language use.","code":""},{"path":"https://eliocamp.github.io/metR/reference/season.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign seasons to months — season","text":"season() returns factor vector length x trimester month. seasonaly() returns date vector length x date \"rounded\" centre month season. .full_season() returns logical vector length x true 3 months season year (December counts following year) present dataset.","code":""},{"path":"https://eliocamp.github.io/metR/reference/season.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign seasons to months — season","text":"","code":"season(1, lang = \"en\") #> [1] DJF #> Levels: DJF MAM JJA SON season(as.Date(\"2017-01-01\")) #> [1] DJF #> Levels: DJF MAM JJA SON  seasonally(as.Date(c(\"2017-12-01\", \"2018-01-01\", \"2018-02-01\"))) #> [1] \"2018-01-15\" \"2018-01-15\" \"2018-01-15\"  is.full_season(as.Date(c(\"2017-12-01\", \"2018-01-01\", \"2018-02-01\", \"2018-03-01\"))) #> [1]  TRUE  TRUE  TRUE FALSE"},{"path":"https://eliocamp.github.io/metR/reference/spherical.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform between spherical coordinates and physical coordinates — spherical","title":"Transform between spherical coordinates and physical coordinates — spherical","text":"Transform longitude latitude interval equivalent meters depending latitude.","code":""},{"path":"https://eliocamp.github.io/metR/reference/spherical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform between spherical coordinates and physical coordinates — spherical","text":"","code":"dlon(dx, lat, a = 6731000)  dlat(dy, a = 6731000)  dx(dlon, lat, a = 6731000)  dy(dlat, a = 6731000)"},{"path":"https://eliocamp.github.io/metR/reference/spherical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform between spherical coordinates and physical coordinates — spherical","text":"dx, dy interval meters lat latitude, degrees radius Earth dlon, dlat interval degrees","code":""},{"path":"https://eliocamp.github.io/metR/reference/spherical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform between spherical coordinates and physical coordinates — spherical","text":"","code":"library(data.table) data(geopotential) geopotential <- geopotential[date == date[1]]  # Geostrophic wind geopotential[, c(\"u\", \"v\") := GeostrophicWind(gh, lon, lat)]  # in meters/second #>         lon   lat   lev       gh       date     u           v #>       <num> <num> <int>    <num>     <Date> <num>       <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01    NA  1.08181190 #>    2:   2.5 -22.5   700 3162.516 1990-01-01    NA  0.55189199 #>    3:   5.0 -22.5   700 3162.226 1990-01-01    NA  0.06625043 #>    4:   7.5 -22.5   700 3162.323 1990-01-01    NA -0.29800162 #>    5:  10.0 -22.5   700 3163.097 1990-01-01    NA -0.75064329 #>   ---                                                         #> 4028: 347.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000 #> 4029: 350.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000 #> 4030: 352.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000 #> 4031: 355.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000 #> 4032: 357.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000 geopotential[, c(\"dlon\", \"dlat\") := .(dlon(u, lat), dlat(v))] # in degrees/second #>         lon   lat   lev       gh       date     u           v  dlon #>       <num> <num> <int>    <num>     <Date> <num>       <num> <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01    NA  1.08181190    NA #>    2:   2.5 -22.5   700 3162.516 1990-01-01    NA  0.55189199    NA #>    3:   5.0 -22.5   700 3162.226 1990-01-01    NA  0.06625043    NA #>    4:   7.5 -22.5   700 3162.323 1990-01-01    NA -0.29800162    NA #>    5:  10.0 -22.5   700 3163.097 1990-01-01    NA -0.75064329    NA #>   ---                                                               #> 4028: 347.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4029: 350.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4030: 352.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4031: 355.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4032: 357.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #>                dlat #>               <num> #>    1:  9.208625e-06 #>    2:  4.697828e-06 #>    3:  5.639385e-07 #>    4: -2.536657e-06 #>    5: -6.389644e-06 #>   ---               #> 4028:  0.000000e+00 #> 4029:  0.000000e+00 #> 4030:  0.000000e+00 #> 4031:  0.000000e+00 #> 4032:  0.000000e+00 geopotential[, c(\"u2\", \"v2\") := .(dx(dlon, lat), dy(dlat))]   # again in degrees/second #>         lon   lat   lev       gh       date     u           v  dlon #>       <num> <num> <int>    <num>     <Date> <num>       <num> <num> #>    1:   0.0 -22.5   700 3163.839 1990-01-01    NA  1.08181190    NA #>    2:   2.5 -22.5   700 3162.516 1990-01-01    NA  0.55189199    NA #>    3:   5.0 -22.5   700 3162.226 1990-01-01    NA  0.06625043    NA #>    4:   7.5 -22.5   700 3162.323 1990-01-01    NA -0.29800162    NA #>    5:  10.0 -22.5   700 3163.097 1990-01-01    NA -0.75064329    NA #>   ---                                                               #> 4028: 347.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4029: 350.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4030: 352.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4031: 355.0 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #> 4032: 357.5 -90.0   700 2715.936 1990-01-01    NA  0.00000000    NA #>                dlat    u2          v2 #>               <num> <num>       <num> #>    1:  9.208625e-06    NA  1.08181190 #>    2:  4.697828e-06    NA  0.55189199 #>    3:  5.639385e-07    NA  0.06625043 #>    4: -2.536657e-06    NA -0.29800162 #>    5: -6.389644e-06    NA -0.75064329 #>   ---                                 #> 4028:  0.000000e+00    NA  0.00000000 #> 4029:  0.000000e+00    NA  0.00000000 #> 4030:  0.000000e+00    NA  0.00000000 #> 4031:  0.000000e+00    NA  0.00000000 #> 4032:  0.000000e+00    NA  0.00000000"},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard atmosphere — standard_atmosphere","title":"Standard atmosphere — standard_atmosphere","text":"Utilities use International Standard Atmosphere. uses International Standard Atmosphere tropopause (11 km definition) extends 500 km using ARDC Model Atmosphere.","code":""},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard atmosphere — standard_atmosphere","text":"","code":"sa_pressure(height)  sa_height(pressure)  sa_temperature(height)  sa_height_trans(pressure_in = \"hPa\", height_in = \"km\")  sa_pressure_trans(height_in = \"km\", pressure_in = \"hPa\")  sa_height_breaks(n = 6, pressure_in = \"hPa\", height_in = \"km\", ...)  sa_height_axis(   name = ggplot2::waiver(),   breaks = sa_height_breaks(pressure_in = pressure_in, height_in = height_in),   labels = ggplot2::waiver(),   guide = ggplot2::waiver(),   pressure_in = \"hPa\",   height_in = \"km\" )  sa_pressure_axis(   name = ggplot2::waiver(),   breaks = scales::log_breaks(n = 6),   labels = scales::number_format(drop0trailing = TRUE, big.mark = \"\", trim = FALSE),   guide = ggplot2::waiver(),   height_in = \"km\",   pressure_in = \"hPa\" )"},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard atmosphere — standard_atmosphere","text":"height height meter pressure pressure pascals height_in, pressure_in units height pressure, respectively. Possible values \"km\", \"m\" height \"hPa\" \"Pa\" pressure. Alternatively, can numeric constant multiplied convert unit meters Pascals respectively. (E.g. height feet, use height_in = 0.3048.) n desired number breaks. ... extra arguments passed scales::breaks_extended. name, breaks, labels, guide arguments passed ggplot2::sec_axis()","code":""},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Standard atmosphere — standard_atmosphere","text":"sa_pressure(), sa_height(), sa_temperature() return, respectively, pressure (pascals), height (meters) temperature (Kelvin). sa_height_trans() sa_pressure_trans() two transformation functions used trans argument ggplot2 scales (e.g. scale_y_continuous(trans = \"sa_height\"). sa_height_axis()  sa_pressure_axis() return secondary axis transforms height pressure respectively used ggplot2 secondary axis (e.g. scale_y_continuous(sec.axis = sa_height_axis())). convenience, unlike \"primitive\" functions, transformation functions axis functions input output hectopascals kilometres default.","code":""},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Standard atmosphere — standard_atmosphere","text":"Standard atmosphere—Glossary Meteorology. (n.d.). Retrieved 22 February 2021, https://glossary.ametsoc.org/wiki/Standard_atmosphere","code":""},{"path":"https://eliocamp.github.io/metR/reference/standard_atmosphere.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standard atmosphere — standard_atmosphere","text":"","code":"height <- seq(0, 100*1000, by = 1*200)  # Temperature profile that defines the standard atmosphere (in degrees Celsius) plot(sa_temperature(height) - 273.15, height, type = \"l\")   # Pressure profile plot(sa_pressure(height), height, type = \"l\")   # Use with ggplot2 library(ggplot2) data <- data.frame(height = height/1000,               # height in kilometers                    pressure = sa_pressure(height)/100) # pressures in hectopascals  # With the sa_*_axis functions, you can label the approximate height # when using isobaric coordinates#' ggplot(data, aes(height, pressure)) +   geom_path() +   scale_y_continuous(sec.axis = sa_height_axis(\"height\"))   # Or the approximate pressure when using physical height ggplot(data, aes(pressure, height)) +   geom_path() +   scale_y_continuous(sec.axis = sa_pressure_axis(\"level\"))   # When working with isobaric coordinates,using a linear scale exagerates # the thickness of the lower levels ggplot(temperature[lat == 0], aes(lon, lev)) +    geom_contour_fill(aes(z = air)) +    scale_y_reverse()   # Using the standard atmospehre height transormation, the result # is an approximate linear scale in height ggplot(temperature[lat == 0], aes(lon, lev)) +    geom_contour_fill(aes(z = air)) +    scale_y_continuous(trans = \"sa_height\", expand = c(0, 0))   # The result is very similar to using a reverse log transform, which is the # current behaviour of scale_y_level(). This transformation slightly # overextends the higher levels. ggplot(temperature[lat == 0], aes(lon, lev)) +    geom_contour_fill(aes(z = air)) +    scale_y_level()"},{"path":"https://eliocamp.github.io/metR/reference/stat_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter only NA values. — stat_na","title":"Filter only NA values. — stat_na","text":"Useful indicating masking missing data. stat subsets data one variable NA.","code":""},{"path":"https://eliocamp.github.io/metR/reference/stat_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter only NA values. — stat_na","text":"","code":"stat_na(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   ...,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/stat_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter only NA values. — stat_na","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders().","code":""},{"path":"https://eliocamp.github.io/metR/reference/stat_na.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Filter only NA values. — stat_na","text":"stat_na understands following aesthetics (required aesthetics bold) x y na width height","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/stat_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter only NA values. — stat_na","text":"","code":"library(ggplot2) library(data.table) surface <- reshape2::melt(volcano) surface <- within(surface, value[Var1 %between% c(20, 30) & Var2 %between% c(20, 30)] <- NA) surface[sample(1:nrow(surface), 100, replace = FALSE), 3] <- NA  ggplot(surface, aes(Var1, Var2, z = value)) +     geom_contour_fill(na.fill = TRUE) +     stat_na(aes(na = value), geom = \"tile\") #> Warning: Imputing missing values."},{"path":"https://eliocamp.github.io/metR/reference/stat_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset values — stat_subset","title":"Subset values — stat_subset","text":"Removes values subset evaluates FALSE. Useful showing statistical significant values, interesting subset data without manually subsetting data.","code":""},{"path":"https://eliocamp.github.io/metR/reference/stat_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset values — stat_subset","text":"","code":"stat_subset(   mapping = NULL,   data = NULL,   geom = \"point\",   position = \"identity\",   ...,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://eliocamp.github.io/metR/reference/stat_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset values — stat_subset","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders().","code":""},{"path":"https://eliocamp.github.io/metR/reference/stat_subset.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Subset values — stat_subset","text":"stat_subset understands following aesthetics (required aesthetics bold) x y subset width height","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/stat_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset values — stat_subset","text":"","code":"library(ggplot2) ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +     geom_contour(aes(z = value)) +     stat_subset(aes(subset = value >= 150 & value <= 160),                 shape = 3, color = \"red\")"},{"path":"https://eliocamp.github.io/metR/reference/surface.html","id":null,"dir":"Reference","previous_headings":"","what":"Surface height — surface","title":"Surface height — surface","text":"Surface height central Argentina lambert grid.","code":""},{"path":"https://eliocamp.github.io/metR/reference/surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Surface height — surface","text":"","code":"surface"},{"path":"https://eliocamp.github.io/metR/reference/surface.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Surface height — surface","text":"data.table 53224 rows 5 variables. lon longitude degrees lat latitude degrees height height meters x x coordinates projection y y coordinates projection","code":""},{"path":"https://eliocamp.github.io/metR/reference/temperature.html","id":null,"dir":"Reference","previous_headings":"","what":"Air temperature — temperature","title":"Air temperature — temperature","text":"global air temperature field 2017-07-09.","code":""},{"path":"https://eliocamp.github.io/metR/reference/temperature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Air temperature — temperature","text":"","code":"temperature"},{"path":"https://eliocamp.github.io/metR/reference/temperature.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Air temperature — temperature","text":"data.table 10512 rows 3 variables: lon longitude degrees 0 360 lat latitude degrees lev pressure level hPa) air air temperature Kelvin","code":""},{"path":"https://eliocamp.github.io/metR/reference/temperature.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Air temperature — temperature","text":"https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html","code":""},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":null,"dir":"Reference","previous_headings":"","what":"Thermodynamics — thermodynamics","title":"Thermodynamics — thermodynamics","text":"Functions related common atmospheric thermodynamic relationships.","code":""},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thermodynamics — thermodynamics","text":"","code":"IdealGas(p, t, rho, R = 287.058)  Adiabat(p, t, theta, p0 = 1e+05, kappa = 2/7)  VirtualTemperature(p, t, e, tv, epsilon = 0.622)  MixingRatio(p, e, w, epsilon = 0.622)  ClausiusClapeyron(t, es)  DewPoint(p, ws, td, epsilon = 0.622)"},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Thermodynamics — thermodynamics","text":"p pressure t temperature rho density R gas constant air theta potential temperature p0 reference pressure kappa ratio dry air constant specific heat capacity constant pressure e vapour partial pressure tv virtual temperature epsilon ratio dry air constant vapour constant w mixing ratio es saturation vapour partial pressure ws saturation mixing ratio td dewpoint","code":""},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Thermodynamics — thermodynamics","text":"function returns value missing state variable.","code":""},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Thermodynamics — thermodynamics","text":"IdealGas computes pressure, temperature density air according ideal gas law \\(P=\\rho R T\\). Adiabat computes pressure, temperature potential temperature according adiabatic relationship \\(\\theta = T (P0/P)^\\kappa\\). VirtualTemperature computes pressure, temperature, vapour partial pressure virtual temperature according virtual temperature definition \\(T(1 - e/P(1 - \\epsilon))^{-1}\\). MixingRatio computes pressure, vapour partial temperature, mixing ratio according \\(w = \\epsilon e/(P - e)\\). ClausiusClapeyron computes saturation pressure temperature according August-Roche-Magnus formula \\(es = exp{bT/(T + c)}\\) temperature Kelvin saturation pressure Pa. DewPoint computes pressure, saturation mixing ration dew point relationship \\(ws =  \\epsilon es(Td)/(p - es(Td))\\). Note computation dew point approximated. important take note units variable provided. default values, pressure passed Pascals, temperature potential temperature Kelvins, density \\(kg/m^3\\). ClausiusClayperon DewPoint require return values units. defaults value R kappa parameters correct dry air, case moist air, use virtual temperature instead actual temperature.","code":""},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Thermodynamics — thermodynamics","text":"http://www.atmo.arizona.edu/students/courselinks/fall11/atmo551a/ATMO_451a_551a_files/WaterVapor.pdf","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/thermodynamics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thermodynamics — thermodynamics","text":"","code":"IdealGas(1013*100, 20 + 273.15) #> [1] 1.203788 IdealGas(1013*100, rho = 1.15) - 273.15 #> [1] 33.71118  (theta <- Adiabat(70000, 20 + 273.15)) #> [1] 324.5993 Adiabat(70000, theta = theta) - 273.15 #> [1] 20  # Relative humidity from T and Td t <- 25 + 273.15 td <- 20 + 273.15 p <- 1000000 (rh <- ClausiusClapeyron(td)/ClausiusClapeyron(t)) #> [1] 0.7380251  # Mixing ratio ws <- MixingRatio(p, ClausiusClapeyron(t)) w <- ws*rh DewPoint(p, w) - 273.15    # Recover Td #> [1] 20.01339"},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":null,"dir":"Reference","previous_headings":"","what":"Fourier transform functions — waves","title":"Fourier transform functions — waves","text":"Use fft() fit, filter reconstruct signals frequency domain, well compute wave envelope.","code":""},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fourier transform functions — waves","text":"","code":"FitWave(y, k = 1)  BuildWave(   x,   amplitude,   phase,   k,   wave = list(amplitude = amplitude, phase = phase, k = k),   sum = TRUE )  FilterWave(y, k, action = sign(k[k != 0][1]))  WaveEnvelope(y)"},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fourier transform functions — waves","text":"y numeric vector transform k numeric vector wave numbers x numeric vector locations (radians) amplitude numeric vector amplitudes phase numeric vector phases wave optional list output FitWave sum whether perform sum (see Details) action integer disambiguate action k = 0 (see Details)","code":""},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fourier transform functions — waves","text":"FitWaves returns named list components k wavenumbers amplitude amplitude wavenumber phase phase wavenumber radians r2 explained variance wavenumber BuildWave returns vector length x reconstructed vector sum TRUE , instead, list components k wavenumbers x vector locations y reconstructed signal wavenumber FilterWave WaveEnvelope return vector length y `","code":""},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fourier transform functions — waves","text":"FitWave performs fourier transform input vector returns list parameters wave number kept.  amplitude (), phase (\\(\\phi\\)) wave number (k) satisfy: $$y = \\sum cos((x - \\phi)k)$$ phase calculated lies 0 \\(2\\pi/k\\) represents location (radians) first maximum wave number. case k = 0 (mean), phase arbitrarily set 0. BuildWave FitWave's inverse. reconstructs original data selected wavenumbers. sum TRUE (default) performs mentioned sum returns single vector. FALSE, returns list k vectors consisting reconstructed signal wavenumber. FilterWave filters removes wavenumbers specified k. k positive, result reconstructed signal y wavenumbers specified k, negative, signal y minus wavenumbers specified k. argument action must manually set -1 +1 k=0. WaveEnvelope computes wave envelope y following Zimin (2003). compute envelope restricted band, first filter FilterWave.","code":""},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fourier transform functions — waves","text":"Zimin, .V., . Szunyogh, D.J. Patil, B.R. Hunt, E. Ott, 2003: Extracting Envelopes Rossby Wave Packets. Mon. Wea. Rev., 131, 1011–1017, doi:10.1175/1520-0493(2003)131<1011:EEORWP>2.0.CO;2","code":""},{"path":[]},{"path":"https://eliocamp.github.io/metR/reference/waves.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fourier transform functions — waves","text":"","code":"# Build a wave with specific wavenumber profile waves <- list(k = 1:10,               amplitude = rnorm(10)^2,               phase = runif(10, 0, 2*pi/(1:10))) x <- BuildWave(seq(0, 2*pi, length.out = 60)[-1], wave = waves)  # Just fancy FFT FitWave(x, k = 1:10) #> $amplitude #>  [1] 0.031639811 0.222183229 2.275286190 0.020037645 0.521286930 0.006932046 #>  [7] 0.261543066 0.011468912 1.948771665 0.241891010 #>  #> $phase #>  [1] 4.80636512 0.23540576 1.96704693 0.10808491 0.36202644 0.26751500 #>  [7] 0.13034289 0.70324492 0.05378108 0.20742644 #>  #> $k #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $r2 #>  [1] 1.062237e-04 5.238128e-03 5.493203e-01 4.260366e-05 2.883416e-02 #>  [6] 5.098900e-06 7.258385e-03 1.395719e-05 4.029726e-01 6.208591e-03 #>   # Extract only specific wave components plot(FilterWave(x,  1), type = \"l\")  plot(FilterWave(x,  2), type = \"l\")  plot(FilterWave(x,  1:4), type = \"l\")   # Remove components from the signal plot(FilterWave(x,  -4:-1), type = \"l\")   # The sum of the two above is the original signal (minus floating point errors) all.equal(x, FilterWave(x,  1:4) + FilterWave(x,  -4:-1)) #> [1] TRUE  # The Wave envelopes shows where the signal is the most \"wavy\". plot(x, type = \"l\", col = \"grey\") lines(WaveEnvelope(x), add = TRUE) #> Warning: \"add\" is not a graphical parameter   # Examples with real data data(geopotential) library(data.table) # January mean of geopotential height jan <- geopotential[month(date) == 1, .(gh = mean(gh)), by = .(lon, lat)]  # Stationary waves for each latitude jan.waves <- jan[, FitWave(gh, 1:4), by = .(lat)] library(ggplot2) ggplot(jan.waves, aes(lat, amplitude, color = factor(k))) +     geom_line()   # Build field of wavenumber 1 jan[, gh.1 := BuildWave(lon*pi/180, wave = FitWave(gh, 1)), by = .(lat)] #>         lon   lat       gh     gh.1 #>       <num> <num>    <num>    <num> #>    1:   0.0 -22.5 3167.817 11.73417 #>    2:   2.5 -22.5 3166.253 11.84884 #>    3:   5.0 -22.5 3165.204 11.94097 #>    4:   7.5 -22.5 3164.823 12.01036 #>    5:  10.0 -22.5 3165.247 12.05689 #>   ---                               #> 4028: 347.5 -90.0 2701.129  0.00000 #> 4029: 350.0 -90.0 2701.129  0.00000 #> 4030: 352.5 -90.0 2701.129  0.00000 #> 4031: 355.0 -90.0 2701.129  0.00000 #> 4032: 357.5 -90.0 2701.129  0.00000 ggplot(jan, aes(lon, lat)) +     geom_contour(aes(z = gh.1, color = after_stat(level))) +     coord_polar()   # Build fields of wavenumber 1 and 2 waves <- jan[, BuildWave(lon*pi/180, wave = FitWave(gh, 1:2), sum = FALSE), by = .(lat)] waves[, lon := x*180/pi] #>         lat     k          x        y   lon #>       <num> <num>      <num>    <num> <num> #>    1: -22.5     1 0.00000000 11.73417   0.0 #>    2: -22.5     1 0.04363323 11.84884   2.5 #>    3: -22.5     1 0.08726646 11.94097   5.0 #>    4: -22.5     1 0.13089969 12.01036   7.5 #>    5: -22.5     1 0.17453293 12.05689  10.0 #>   ---                                       #> 8060: -90.0     2 6.06501915  0.00000 347.5 #> 8061: -90.0     2 6.10865238  0.00000 350.0 #> 8062: -90.0     2 6.15228561  0.00000 352.5 #> 8063: -90.0     2 6.19591884  0.00000 355.0 #> 8064: -90.0     2 6.23955208  0.00000 357.5 ggplot(waves, aes(lon, lat)) +     geom_contour(aes(z = y, color = after_stat(level))) +     facet_wrap(~k) +     coord_polar()   # Field with waves 0 to 2 filtered jan[, gh.no12 := gh - BuildWave(lon*pi/180, wave = FitWave(gh, 0:2)), by = .(lat)] #>         lon   lat       gh     gh.1  gh.no12 #>       <num> <num>    <num>    <num>    <num> #>    1:   0.0 -22.5 3167.817 11.73417 5.858149 #>    2:   2.5 -22.5 3166.253 11.84884 4.006104 #>    3:   5.0 -22.5 3165.204 11.94097 2.689758 #>    4:   7.5 -22.5 3164.823 12.01036 2.061137 #>    5:  10.0 -22.5 3165.247 12.05689 2.261535 #>   ---                                        #> 4028: 347.5 -90.0 2701.129  0.00000 0.000000 #> 4029: 350.0 -90.0 2701.129  0.00000 0.000000 #> 4030: 352.5 -90.0 2701.129  0.00000 0.000000 #> 4031: 355.0 -90.0 2701.129  0.00000 0.000000 #> 4032: 357.5 -90.0 2701.129  0.00000 0.000000 ggplot(jan, aes(lon, lat)) +     geom_contour(aes(z = gh.no12, color = after_stat(level))) +     coord_polar()   # Much faster jan[, gh.no12 := FilterWave(gh, -2:0), by = .(lat)] #>         lon   lat       gh     gh.1  gh.no12 #>       <num> <num>    <num>    <num>    <num> #>    1:   0.0 -22.5 3167.817 11.73417 5.858149 #>    2:   2.5 -22.5 3166.253 11.84884 4.006104 #>    3:   5.0 -22.5 3165.204 11.94097 2.689758 #>    4:   7.5 -22.5 3164.823 12.01036 2.061137 #>    5:  10.0 -22.5 3165.247 12.05689 2.261535 #>   ---                                        #> 4028: 347.5 -90.0 2701.129  0.00000 0.000000 #> 4029: 350.0 -90.0 2701.129  0.00000 0.000000 #> 4030: 352.5 -90.0 2701.129  0.00000 0.000000 #> 4031: 355.0 -90.0 2701.129  0.00000 0.000000 #> 4032: 357.5 -90.0 2701.129  0.00000 0.000000 ggplot(jan, aes(lon, lat)) +     geom_contour(aes(z = gh.no12, color = after_stat(level))) +     coord_polar()   # Using positive numbers returns the field jan[, gh.only12 := FilterWave(gh, 2:1), by = .(lat)] #>         lon   lat       gh     gh.1  gh.no12 gh.only12 #>       <num> <num>    <num>    <num>    <num>     <num> #>    1:   0.0 -22.5 3167.817 11.73417 5.858149  11.17110 #>    2:   2.5 -22.5 3166.253 11.84884 4.006104  11.45865 #>    3:   5.0 -22.5 3165.204 11.94097 2.689758  11.72661 #>    4:   7.5 -22.5 3164.823 12.01036 2.061137  11.97348 #>    5:  10.0 -22.5 3165.247 12.05689 2.261535  12.19776 #>   ---                                                  #> 4028: 347.5 -90.0 2701.129  0.00000 0.000000   0.00000 #> 4029: 350.0 -90.0 2701.129  0.00000 0.000000   0.00000 #> 4030: 352.5 -90.0 2701.129  0.00000 0.000000   0.00000 #> 4031: 355.0 -90.0 2701.129  0.00000 0.000000   0.00000 #> 4032: 357.5 -90.0 2701.129  0.00000 0.000000   0.00000 ggplot(jan, aes(lon, lat)) +     geom_contour(aes(z = gh.only12, color = after_stat(level))) +     coord_polar()   # Compute the envelope of the geopotential jan[, envelope := WaveEnvelope(gh.no12), by = .(lat)] #>         lon   lat       gh     gh.1  gh.no12 gh.only12  envelope #>       <num> <num>    <num>    <num>    <num>     <num>     <num> #>    1:   0.0 -22.5 3167.817 11.73417 5.858149  11.17110 10.834194 #>    2:   2.5 -22.5 3166.253 11.84884 4.006104  11.45865  9.544124 #>    3:   5.0 -22.5 3165.204 11.94097 2.689758  11.72661  8.173016 #>    4:   7.5 -22.5 3164.823 12.01036 2.061137  11.97348  6.906214 #>    5:  10.0 -22.5 3165.247 12.05689 2.261535  12.19776  5.958197 #>   ---                                                            #> 4028: 347.5 -90.0 2701.129  0.00000 0.000000   0.00000  0.000000 #> 4029: 350.0 -90.0 2701.129  0.00000 0.000000   0.00000  0.000000 #> 4030: 352.5 -90.0 2701.129  0.00000 0.000000   0.00000  0.000000 #> 4031: 355.0 -90.0 2701.129  0.00000 0.000000   0.00000  0.000000 #> 4032: 357.5 -90.0 2701.129  0.00000 0.000000   0.00000  0.000000 ggplot(jan[lat == -60], aes(lon, gh.no12)) +     geom_line() +     geom_line(aes(y = envelope), color = \"red\")"},{"path":[]},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0183","dir":"Changelog","previous_headings":"","what":"metR 0.18.3","title":"metR 0.18.3","text":"CRAN release: 2025-12-09","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-18-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"metR 0.18.3","text":"Fixed () notation ReadNetCDF() subset.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0182","dir":"Changelog","previous_headings":"","what":"metR 0.18.2","title":"metR 0.18.2","text":"CRAN release: 2025-09-05","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-18-2","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.18.2","text":"ReadNetCDF() now supports cdo operations via rcdo package. can pass rcdo operation executed. ReadNetCDF() gains support reading data multiple files potentially parallel.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-18-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"metR 0.18.2","text":"ResidLm() now returns vector NAs. ReadNetCDF() subset used return data based coordinate closest subset dimensions. mean subset = list(lat = c(-90, -20)) return data north 20°S gridpoint north 20°S closer 20°S gridpoint South . problem general, fail catastrophically file didn’t data inside requested range. now fixed returns data inside desired range.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0181","dir":"Changelog","previous_headings":"","what":"metR 0.18.1","title":"metR 0.18.1","text":"CRAN release: 2025-05-13","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-18-1","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.18.1","text":"geom_streamline() replace missing values zeroes. New ParseNetCDFtime() quickly parse netCDF time axes.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"potentially-breaking-changes-0-18-1","dir":"Changelog","previous_headings":"","what":"Potentially breaking changes","title":"metR 0.18.1","text":"ReadNetCDF() now uses CFtime package parse times. shouldn’t lead braking changes, times weird anything can happen. Please report anything amiss. Contour breaks now computed scale transformation. Previously computed using whole dataset, lead nonsensical contour breaks scale limits removed extreme values.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"other-stuff-0-18-1","dir":"Changelog","previous_headings":"","what":"Other stuff","title":"metR 0.18.1","text":"Reworked ordering algorithm tanaka contours.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0180","dir":"Changelog","previous_headings":"","what":"metR 0.18.0","title":"metR 0.18.0","text":"CRAN release: 2025-02-24","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-18-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.18.0","text":"ReadNetCDF() can now subset based dimension indices instead dimension values. makes possible read “first 10 timesteps” “last 10 timesteps” without needing know dates correspond many timesteps total.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0170","dir":"Changelog","previous_headings":"","what":"metR 0.17.0","title":"metR 0.17.0","text":"CRAN release: 2025-01-13","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-17-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"metR 0.17.0","text":"Longitude scales now properly pass trans/transform argument.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0160","dir":"Changelog","previous_headings":"","what":"metR 0.16.0","title":"metR 0.16.0","text":"CRAN release: 2024-10-14","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-16-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.16.0","text":"EOF()’s rotate argument now take function apply EOF loadings. rotate = TRUE still supported deprecated default using function(x) stats::varimax(x, normalize = FALSE). Contour functions gain proj.latlon decide projection needs go latlon coordinates projected coordinates.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-16-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.16.0","text":"GetSMNData() function defunct. functionality hack hard maintain ’s also specific scope general package. trans argument scales renamed transform following ggplot2’s change. scale_mag() internals now much simpler inherits functionality common continuous scales. (thanks @teunbrand suggestion, #186) step computed variable geom_streamline() now goes 0 total number steps instead negative half positive half.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0150","dir":"Changelog","previous_headings":"","what":"metR 0.15.0","title":"metR 0.15.0","text":"CRAN release: 2024-02-08","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-15-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.15.0","text":"contour functions gain clip argument show contours area defined polygon. kriging argument contour functions now can numeric control de number pixels used. Documentation FitWave() friends improved (#184, @pascaloettli).","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-15-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.15.0","text":"proj argument geom_contour_fill() friends now operate isolines returned isoband package. might break code used custom function proj.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-15-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"metR 0.15.0","text":"Guides compatible new versions ggplot2 (#117 #185, @teunbrand). Contour functions work even OutDec “.”.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0141","dir":"Changelog","previous_headings":"","what":"metR 0.14.1","title":"metR 0.14.1","text":"CRAN release: 2023-10-30","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-14-1","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"metR 0.14.1","text":"DivideTimeseries() function now defunct.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-14-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.14.1","text":"FitLm() gains new intercept argument allows remove intercept term automatically added.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-14-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"metR 0.14.1","text":"Fixes error Laplacian() computing laplacian single variable. (#170, Thanks @pascaloettli) Removes dependencies raster gdal packages.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0140","dir":"Changelog","previous_headings":"","what":"metR 0.14.0","title":"metR 0.14.0","text":"CRAN release: 2023-03-23","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-14-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.14.0","text":"really new feature per se, geoms now support new linewidth aesthetic. geom_relief() geom_shadow() now don’t size aesthetic, since shouldn’t anyway. value maximum vector magnitude scale_mag() now chosen “pretty” number close maximum. prevent guides many unnecesary decimal places (thanks, @PanfengZhang #161).","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-14-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"metR 0.14.0","text":"Documents correct default expand value sale_x_longitude() friends (thanks, @tamas-ferenci, #167). Fixes inconsistencies generic methods.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0130","dir":"Changelog","previous_headings":"","what":"metR 0.13.0","title":"metR 0.13.0","text":"CRAN release: 2022-10-06","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-13-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.13.0","text":"new function Smooth2D() smooths 2D field (hence name). two smoothing methods. smooth_svd() computes SVD field reconstructs keeping leading values ensures maximum variance lost. smooth_dct() computes Discrete Cosine Transform field sets proportion components zero.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-13-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"metR 0.13.0","text":"Fixed bug geom_streamline() plotting multiple fields panel. Fixes bug GetTopography() Windows. Updates documentation use valid HTML5 per CRAN’s new format. Fixes “following aesthetics dropped statistical transformation” warning contours. Removes ReadNetCDF() file URL checking didn’t work cases. (#164, thanks @pascaloettli)","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-13-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.13.0","text":"Due udunits2 package orphaned, ReadNetCDF() longer uses parse dates times. homebrewed parser might limited, wild variety netCDF files wild makes hard fully test. Please report issues !","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0120","dir":"Changelog","previous_headings":"","what":"metR 0.12.0","title":"metR 0.12.0","text":"CRAN release: 2022-02-15","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-12-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.12.0","text":"Adds example scale_y_level() (@paocorrales, #153). ReadNetCDF() now parse times correctly even use non-standard calendars. now makes udunits2 PCICt required parse time. Arrays returned ReadNetCDF(…, = \"array\") gain “dimvalues” attribute analogous dimnames correct types (dates dates, numerics numerics, etc…). EOF() gains new engine argument chose function compute singular value decomposition.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bug-fixes-0-12-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"metR 0.12.0","text":"Fixed wrong sdev component EOF() using base::svd() cases. seasonally() now returns Date object even input datetime. avoids issues time component input . Fixed bug ImputeEOF() algorithm tried compute 0 EOFs.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0110","dir":"Changelog","previous_headings":"","what":"metR 0.11.0","title":"metR 0.11.0","text":"CRAN release: 2021-09-20","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.11.0","text":"geom_contour2() gains ability draw –leave space – labels! finally proper labelling support without use different geom (geom_text_contour()). Thanks isoband package . Following isoband’s naming convention, family functions decide place labels renamed label_placer_ corresponding argument now label.placer . label_placement_ family functions deprecated future releases.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-0100","dir":"Changelog","previous_headings":"","what":"metR 0.10.0","title":"metR 0.10.0","text":"CRAN release: 2021-08-07","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-10-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.10.0","text":"discretised scales now work better passing user-supplied limits. New functions use International Standard Atmosphere get height pressure vice versa, well use secondary axis. See ?standard_atmosphere. scale_y_level() scale_x_level() now print breaks default. functions probably use transformation instead reverse log transformation future release. Translation! Thanks @MichaelChirico priceless guidance, metR messages now translatable already translated Spanish. using R Spanish locale getting messages error Spanish. Partial translation Portuguese also included. process translating messages, many messages improved made consistent. New Function ResidLm() returns residuals linear fit. New function Detrend() , guessed , returns (linearly) detrended version input vector. ReadNetCDF(), “vars” argument now can take function. (#142) Discretised scales now support user-defined breaks.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-10-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.10.0","text":"seasonally() result 15th centre month season instead 1st. makes date representative time span also solves bug dates 31st return NA. potentially breaking change. ReadNetCDF() doesn’t fail reading variables dimensions (thanks @paocorrales, #141).","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-092","dir":"Changelog","previous_headings":"","what":"metR 0.9.2","title":"metR 0.9.2","text":"CRAN release: 2021-05-20","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-9-2","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.9.2","text":"Fixes bug geom_contour_tanaka() R >= 4.1.0.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-091","dir":"Changelog","previous_headings":"","what":"metR 0.9.1","title":"metR 0.9.1","text":"CRAN release: 2021-02-07","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-9-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.9.1","text":".discretised_scale() quick way created discretised version continuous scale. stroke.colour now accepted aesthetic geom_text_contour().","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-9-1","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.9.1","text":"computations MixingRatio() wrong. Now fixed. really wanted geom_arrow() automatically add arrow legend, workarounds managed write brittle couldn’t handle even slight changes people’s code (see https://github.com/eliocamp/metR/issues/130). definitive answer simply possible due limitations ggplot2 works (see https://github.com/tidyverse/ggplot2/issues/4291). release, , backtracks workarounds tries accept things change.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-090","dir":"Changelog","previous_headings":"","what":"metR 0.9.0","title":"metR 0.9.0","text":"CRAN release: 2020-11-25","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"metR 0.9.0","text":"’m happy discretised_scale(), type scale takes discrete values result discretisation treats continuous. ’s, sense, inverse new ggplot2::binned_scale(). Whereas. ggplot2::binned_scale() takes continuous values discretises , discretised_scale() takes discrete values result discretisation procedure (levels geom_contour_fill()/ggplot2::geom_contour_filled()) allows treat continuous. Related , geom_contour_fill() now gains new computed aesthetic called level_d, level forces ggplot2 automatically use new discretised scale. AnchorBreaks() gains bins argument mimic default functionality MakeBreaks(). New label_placement_minmax() label contours maximum minimum points contour (mimicking isoband’s behaviour) geom_contour_tanaka() now (rather experimental) argument smooth allows smooth transition segments.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.9.0","text":"Fixes error introduced previous version geom_arrow() mappings dx dy. (Thanks Santiago!) level derived aesthetic geom_contour_fill() now returns ordered factor correct labels can interpreted ggplot2::guide_colorsteps(). might breaking change! geom_label_contour() lives! previous release rewrote much way geom_text_contour() worked, messed didn’t realised new code broken geom_label_contour() (honest, ’d almost totally forgotten :P). (fixes #126, thanks @kongdd)","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-080","dir":"Changelog","previous_headings":"","what":"metR 0.8.0","title":"metR 0.8.0","text":"CRAN release: 2020-10-25","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.8.0","text":"geom_text_contour() placement labels completely redesigned. gains argument label.placement takes function charge positioning labels. See label_placement_flattest() details possible placement methods build . default method label_placement_flattest, places label product curvature angle contour minimised. aims put labels straight segment also horizontal possible. one point satisfy condition, chooses closest midpoint. breaking change, change label position previous plots. contour functions also gain proj argument. can proj4 string project contours arbitrary function alter contours computed. now makes possible compute contours data regular grid projected coordinates want plot lon-lat coordinates (vice versa). Bear mind contours cross dateline probably end mangled. Contour functions also gain kriging argument. TRUE, perform ordinary kriging interpolate irregularly placed data regular grid.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.8.0","text":"FitLm() handles NAs better. GetSMNData returns date parameter correct time zone. WaveFlux() now returns value horizontal fluxes. , return lon lat. potentially breaking change. contour family functions now use isoband compute contours (thanks @clauswilke awesome package) instead ugly hack/workaround. result, contours faster much reliable. EOF() now work even {irlba} installed. GetTopography() now updated new ETOPO server. now requires {raster} work.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-070","dir":"Changelog","previous_headings":"","what":"metR 0.7.0","title":"metR 0.7.0","text":"CRAN release: 2020-04-10","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.7.0","text":"FitWave() related functions return NAs inputted signal NAs. FitLm() accepts weights argument perform weighted regression. ReadNetCDF() now can read files directly DAP servers urls, objects returned ncdf4::ncopen()ncdf4::nc_open().","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.7.0","text":"ReadNetCDF() won’t try parse “time” dimensions dates try parse time dimensions.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.7.0","text":"seasonaly() now correctly called seasonally(). proves don’t put ESL person charge naming stuff.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-060---pileus","dir":"Changelog","previous_headings":"","what":"metR 0.6.0 - Pileus","title":"metR 0.6.0 - Pileus","text":"CRAN release: 2020-02-10","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.6.0 - Pileus","text":"EPflux() computes Eliassen-Palm fluxes (experimental). geom_arrow() geom_vector() plot faster. New functions .full_season() seasonaly(). FitLm() returns model r2r^2 adjusted r2r^2. FitLm() adds names unnamed terms. New function WaveEnvelope() computes… wave envelope. geom_contour2(), geom_contour_fill() geom_text_contour() now accept global.breaks argument controls whether breaks computed using range whole dataset every grouping (e.g. faceting). TRUE (default) ensures intervals contours comparable panels. Setting FALSE computes contours compatible ggplot2::geom_conotur() (#109, thanks @freeseek)","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.6.0 - Pileus","text":"reworked non-equispaced derivative gives better results Derivate(). ReadNetCDF() fail first variable called “v” (yeah, know.. weird error related data.table’s non standard evaluation). Subsets ReadNetCDF() won’t fail element named (#107, thanks @m-saenger) Fixed bug WaveFlux() (#110, thanks @salvatirehbein)","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"internals-0-6-0","dir":"Changelog","previous_headings":"","what":"Internals","title":"metR 0.6.0 - Pileus","text":"Cleaned lot dependencies. gone (longer needed) moved Suggest. Overall metR now bit lighter install.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-050---incus","dir":"Changelog","previous_headings":"","what":"metR 0.5.0 - Incus","title":"metR 0.5.0 - Incus","text":"CRAN release: 2019-11-12","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.5.0 - Incus","text":"ReadNetCDF() supports using NA subset refer max min value. ReadNetCDF()’s subset argument supports complex queries. (see help section ?ReadNetCDF()). ReadNetCDF() now simple date-time parser tried udunits2 package installed. GetSMNData() gains ability cache results file. Derivate() now can derive non-equispaced grid.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.5.0 - Incus","text":"geom_contour_fill() imputation method fixed special cases (#96; thanks @bergmul). predict.eof() handles complex value svd correctly. Accommodates new grid implementation units (#105 thanks @pmur002).","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-040---cumulonimbus","dir":"Changelog","previous_headings":"","what":"metR 0.4.0 - Cumulonimbus","title":"metR 0.4.0 - Cumulonimbus","text":"CRAN release: 2019-07-08","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.4.0 - Cumulonimbus","text":"New GlanceNetCDF() function alias ReadNetCDF(= \"vars\") now prints human readable summary contents NetCDF file. geom_streamline() now uses 4th order Runge-Kutta instead plain old Euler. also draws arrows middle streamline. ReadNetCDF() slightly faster use less memory. ReadNetCDF() supports complex subsetting operations now. df element returned FitLm() now length rest.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.4.0 - Cumulonimbus","text":"ReadNetCDF() result print correctly.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-030---cumulonimbus","dir":"Changelog","previous_headings":"","what":"metR 0.3.0 - Cumulonimbus","title":"metR 0.3.0 - Cumulonimbus","text":"CRAN release: 2019-03-12","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"metR 0.3.0 - Cumulonimbus","text":"Anomaly() new baseline argument. New function Trajectory() computes trajectories time-varying velocity fields.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"bugfixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"metR 0.3.0 - Cumulonimbus","text":"ReadNetCDF() now accepts dates elements subset. ReadNetCDF() read dates correctly (#91; thanks @m-saenger).","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.3.0 - Cumulonimbus","text":"es argument MixingRatio() changes e, consistent rest variables. Sorry, thermodynamics forte! (thanks @PaoCorrales) Arrow heads geom_arrow() now scaled correctly faceted plots (fixes, #92; thanks @m-saenger)","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-020","dir":"Changelog","previous_headings":"","what":"metR 0.2.0","title":"metR 0.2.0","text":"CRAN release: 2018-11-19","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"metR 0.2.0","text":"changes interface functions sake consistency. Derivate() (’s derived functions –see ?), data argument moved back. function intended called inside data.table mutate() call, don’t need explicitly specify data. EOF() dcast-style formula interface removed. data argument also moved back can use n argument easily without naming . ImputeEOF() follows conventions. dcast-style interface removed data argument moved max.eof argument. BuildQsWave() FitQsWave() removed never even existed. default skip argument geom_text_contour() now 0. Removed hemisphere argument season() since function returns trimester made sense. Contour functions now compute breaks globally (using data) instead per panel. means default intercomparabilty faceted plots also considerable deviation ggplot2::geom_contour(). operators removed since already implemented data.table. default geom stat_na() changed point consistency stat_subset()","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"other-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"metR 0.2.0","text":"Arrows geom_arrow() geom_vector() scale vector magnitude. New geom geom_streamline() visualizing vector fields. Utilities dlon(), dlat(), dx(), dy() converting physical units spherical units. New geom geom_contour_tanaka() plots illuminated contours. New function Interpolate() bilinear interpolation. Fixed bug FitWave() wavenumber 0. Now returns mean. FitWave() runs slightly faster BuildWave() runs much faster. Removed GeomContourFill object since just polygon. results EOF() now use factors instead numbers identify PC New scale scale_mag() guide guide_vector() controlling communicating scale vectors. highly experimental change future, provide needed functionality decided export . geom_arrow() gains new pivot argument control point rotation preserve.dir tell angle preserved. stat_contour_fill() stat_contour2() print warning contours can made. EOF() now supports estimation confidence intervals via bootstrap. EOF() supports varimax rotation. Rotated components labelled accordingly. geom_relief() much faster now (see package rayshader). New geom_shadow() casting shadows topographic maps. Contour calculations StatContour2 memoised computed even adding several layers contours (geom_contour() + geom_text_contour()) running plot tweaking ’s appearance. New FitLm() getting fast estimates linear fits. New FilterWave() filtering waves. Circular dimensions quite ride development process. RepeatCircular() deprecated favour WrapCircular() robust, WrapCircular() deprecated favour ggperiodic package. way stat_contour2(), stat_contour_fill() geom_streamlines() handle circular dimensions changed. Now need use xwrap/ywrap explicitly set domain. makes implementation robust also allow easily wrap arbitrary domain. change, wrapping functionality moved ggperiodic, can handle stuff better. mentioned arguments still work documented deprecated. EOF() gains fill argument sparse-ish data. geom_text_contour() now ability draw stroke around text. geom_contour_fill() now can impute missing values bivariate interpolation. BuildField() actually renamed BuildWave() (’ve happen previous release according News). New function .path() added functionality Interpolate() allows interpolate values along path locations. New function Impute2D() exported version method used geom_contour_fill() (soft) impute missing values. subset argument ReadNetCDF() now accepts character vectors time components.","code":""},{"path":"https://eliocamp.github.io/metR/news/index.html","id":"metr-010","dir":"Changelog","previous_headings":"","what":"metR 0.1.0","title":"metR 0.1.0","text":"New function: GetTopography() ReadNetCDF() now can output arrays vectors. Changed name. New website (https://eliocamp.github.io/metR/) documentation. Thanks pkgdown. New functions: coriolis() coriolis.dy(). Faster Anomaly() (can’t believe ). EOF() principal components numeric instead “PC1”, etc… consistency stat_contour() created geom_contour_fill() works just like stat_contour_fill(). Added stat_na() easy masking NA values. geom_arrow() now geom_vector() better documentation parameters geom_arrow() new geom arrows preserve direction. ReadNetCDF() now handles date formats. New functions Laplacian(), Divercence() Vorticity() DerivatePhysical() removed since made redundant extended functionality Derivate() New functions related several physical processes (see ?physics). New geom_text_contour() geom_label_contour() labelling contours. New function GeostrophicWind(). Fixed? weird bug ReadNetCDF() .POSIXct. ReadNetCDF() now supports time-zones via de udunits2 package. Fixed bad polygon ordering extra polygon stat_contour_fill(). New functions MakeBreaks() AnchorBreaks(). New guide. guide_colorstrip() displays discretized values continuous colour fill scale. Fix unconnected contours stat_contour_fill() New geom_relief() generating relief shading. ReadNetCDF() gains subset argument subsetting data. AnchorBreaks() new way generating breaks. New geom_contour2() takes function argument breaks geom_contour_fill() also . New stat_subset() makes subsetting data fly easier. ReadNetCDF() can return keyed data.table. FitQsWave() BuildQsWave() renamed FitWave() BuildWave(), respectively. GetSMNData() updated include new SMN website data types. geom_contour2() geom_contour_fill() gain circular argument specify circular dimension. RepeatCircular() renamed RepeatCircular(). LonLabel() LatLabel() aid labelling latitude longitude. Changed interface EOF() ImputeEOF().","code":""}]
